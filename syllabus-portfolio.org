#+TITLE:CS 480 Syllabus and Portfolio@@html:<br>@@ Winter 2019
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t ':t
#+OPTIONS: html-postamble:nil
#+STARTUP: entitiespretty

#+Begin_Latex
\pagebreak
#+End_Latex


* What\rsquo{}s It All About? :noexport:
  This course is about the *theory of computation.*

  The following is a partial list of topics that will be covered:

  - Finite Automata
  - Regular Expressions
  - Push-Down Automata
  - Grammars
  - Languages
  - Turing Machines
  - Computability
  - Complexity
  - P, NP and NP-Complete Problems.

  In other words, it\rsquo{}s a blast!

* Objectives :noexport:
 1. Examine the theoretical basis of computer science.
 2. Learn the real limitations and opportunities in computing. This includes:
   - What can and can not be computed (computability),
   - The power of different types of computational systems in terms of what they
     can compute (automata classification, recursive function theory, Chomsky
     Hierarchy),
   - What is practically computable and the complexity of solving certain
     classes of problems (complexity and tractability).
 3. Appreciate and gain proficiency with rigorous methods, representations, and
   proof techniques.
 4. Learn how to apply theoretical concepts to practical problems.

* Prerequisites :noexport:
  You must have successfully completed the following courses:

  - CS 238 Discrete Mathematics II (concurrent enrollment okay)
  - CS 306 Algorithms and Complexity

* Requirements :noexport:
You are required to
+ attend class each class period (but then again, why wouldn\rsquo{}t you?),
+ read assigned portions of the course materials /before/ the class meeting when they will be discussed,
+ complete weekly preparation assessments, and
+ do weekly homework assignments to deepen your understanding of selected topics.

* Text :noexport:
   /Automata and Computability: A Programmer\rsquo{}s Perspective/

   (abbreviated ACAPP)

   *Ganesh Gopalakrishnan*

   /First Edition, 2019, Taylor & Francis/

* Software :noexport:
  (For the first two, see installation instructions [[https://rickneff.github.io][here]] and go to the /Tools/
  section. For the third and fourth, more information will be given later.)
+ git
+ Emacs/Spacemacs
+ python3
+ @@latex:\LaTeX{}@@

** Jove
  https://github.com/ganeshutah/Jove
#+BEGIN_SRC sh :results silent
  cd ~
  git clone https://github.com/ganeshutah/Jove.git
#+END_SRC

  [[file:~/Jove/README.md]]

* Behavioral Requirements :noexport:
You are required to\dots{}
+ attend class, as assessments will happen in class each day that are not reproducible outside of class.
+ read assigned portions of the course materials /before/ class meetings when they will be discussed.
+ complete all team and personal assessments to deepen your understanding of selected topics.
+ acquire and maintain a three-ring binder that will hold your portfolio of completed work (see below).

* Course Periodicity :noexport:
This course has a weekly period, i.e., you can count on knowing ahead of time
what you will be doing each day of each week. Each class period consists of two
30-minute sections.

On Mondays (or Wednesdays where the Monday is a holiday) these sections are:

 - Presentation :: --- A time where I will add depth information to the preparation
                   material you finished reading *before class*.
 - Class Directed Learning :: --- You will participate in a class-wide activity that
      reinforces what you\rsquo{}ve read and what I\rsquo{}ve shown you.

On Fridays these sections are:
 - Answer Questions :: --- I will answer questions that have been submitted to the
      class slack channel (more on which later).
 - Class Directed Learning :: --- You will participate in a class-wide activity that
      reinforces what you\rsquo{}ve read and what I\rsquo{}ve shown you.

* Questions :noexport:
+ The questions answered on Friday are generalized from those you submit via
  the slack channel on Wednesday Evenings.
+ You must submit any and all unanswered questions on Wednesday evening. Not
  submitting questions leads to a reduced learning experience.
+ You will have plenty of questions. Submit them! Choose knowledge over ignorance.

* Exercises :noexport:
Exercises are smaller experiences that are designed to float uncertainties and
questions you have to the surface of your mind. They are designed to be smaller
so you can find out what you don\rsquo{}t know and then take the steps necessary to
know.

* Problems  :noexport:
Problems are weightier experiences that invite you to explore topics in
theoretical computer science --- and especially mathematical proofs --- as well
as increase your logical thinking and problem solving prowess. All involve
writing mathematically.

* Assessment :noexport:
Every four weeks you will meet with me in my office. The purpose
of this meeting is for you to present your portfolio of work to me, make a
grade-to-date claim, and provide evidence justifying that claim.

Your portfolio *MUST* be a modified version of this file. All entries must
follow the example format you will find at the end of this document (when it is
updated). Also, your evidences must be complete and internally consistent. You
are required to produce the portfolio using Spacemacs, export it as a pdf file,
and print it. To accmoplish this you will need @@latex:\LaTeX{}@@ installed on
your machine.

* Late Work :noexport:
Late work is accepted /only if/ the reason is extraordinary, and acceptance is
reached through private and prolonged negotiation. Also, you must come talk to
me in person in my office --- *NOT* by email, nor any other means of
communication.

* Grades :noexport:
In each of our three personal meetings, you will present your portfolio and a
letter-based grade-to-date claim. Afterwards I will give you my thoughts on the
strength of your claim. The last claim that you make, taking into account any
feedback from me, will be your final grade for the course. All of your claims
must must be evidence-based. That means you *MUST* bring the evidence with you,
in your portfolio, that supports your claim.

** Letter-Based
When making your claim, you are required to use the [[http://www.byui.edu/student-records/grades/grading-system][BYU-Idaho standard]]
letter-based definition of grades, reproduced below:

+ \ldquo{}A\rdquo represents outstanding understanding, application, and integration of
  subject material and extensive evidence of original thinking, skillful use of
  concepts, and ability to analyze and solve complex problems. Demonstrates
  diligent application of Learning Model principles, including initiative in
  serving other students.
+ \ldquo{}B\rdquo represents considerable/significant understanding, application, and
  incorporation of the material that would prepare a student to be successful in
  next level courses, graduate school, or employment. The student participates
  in the Learning Model as applied in the course.
+ \ldquo{}C\rdquo represents sufficient understanding of subject matter. The student
  demonstrates minimal initiative to be prepared for class. Sequenced courses
  could be attempted, but mastering new materials might prove challenging. The
  student participates only marginally in the Learning Model.
+ \ldquo{}D\rdquo represents poor performance and initiative to learn and understand and
  apply course materials. Retaking a course or remediation may be necessary to
  prepare for additional instruction in this subject matter.
+ \ldquo{}F\rdquo represents failure in the course.

Note that the above description of an \ldquo{}A\rdquo implies that you have gone *above and
beyond*. To claim this grade you *must* have continually done the following
things throughout the 4-week period and recorded evidence of this behavior in
your portfolio. These behaviors are:
  1. teaching and/or helping others in the class but not in your group;
  2. teaching a Non-CS, Non-CE, Non-EE, Non-SE major about the material in this
     class to help them with a class they are taking;
  3. applying what you've learned in this class in another class you are
     currently taking; and
  4. doing work not assigned such as exploring mathematics, writing code
     implementing what you are learning that has not been assigned, etc.

Regarding the first two, quoting Truman Madsen (quoting the Prophet Joseph
Smith): Now one of the strongest and wisest statements I have ever heard on
egoism. The question was put to him, \ldquo{}Joseph, is the principle of
self-aggrandizement wrong? Should we seek our own good?\rdquo Listen to his answer.
\ldquo{}It is a correct principle and may be indulged upon only one rule or plan ---
and that is to elevate, benefit, and bless others first. If you will elevate
others, the very work itself will exalt you. Upon no other plan can a man justly
and permanently aggrandize himself.\rdquo
* Harassment :noexport:
	Title IX of the Education Amendments of 1972 prohibits sex discrimination
  against any participant in an education program or activity that receives
  federal funds, including Federal loans and grants. Title IX also covers
  student-to-student sexual harassment. If you encounter unlawful sexual
  harassment or gender based discrimination, please contact the Personnel Office
  at 496-1130.

* Disability :noexport:
  Brigham Young University-Idaho is committed to providing a working and
  learning atmosphere which reasonably accommodates qualified persons with
  disabilities. If you have any disability which may impair your ability to
  complete this course successfully, please contact the Services for Students
  with Disabilities Office, 496-1158. Reasonable academic accommodations are
  reviewed for all students who have qualified documented disabilities. Services
  are coordinated with the student and instructor by this office. If you need
  assistance or if you feel you have been unlawfully discriminated against on
  the basis of disability, you may seek resolution through established grievance
  policy and procedures. You should contact the Personnel Office at 496-1130.

* Other :noexport:
  This document may be modified by the instructor at any time without notification.

#+Begin_Latex
\pagebreak
#+End_Latex

* Readings :noexport:

These readings are to be completed *before* each listed week\rsquo{}s Wednesday\rsquo{}s
class. The exercises from each chapter (all of them) are to be completed
*before* close-of-day each Friday.

  | Week | Reading from ACAPP               |
  |------+----------------------------------|
  |   01 | None (Initial Exam Papers only)  |
  |   02 | Chapters 1 and 2, and Appendix A |
  |   03 | Chapters 3 and 4                 |
  |   04 | Chapters 5 and 6                 |
  |   05 | Chapters 7 and 8                 |
  |   06 | Chapters 9 and 10                |
  |   07 | Chapters 11 and 12               |
  |   08 | Chapter 13                       |
  |   09 | Chapter 14                       |
  |   10 | Chapter 15                       |
  |   11 | Chapter 16                       |
  |   12 | Chapter 17                       |
  |   13 | Chapter 18                       |
  |   14 | Finals Week                      |

* Tracker Acronym Key :noexport:
Course Tracker acronyms and their meanings.

	+ CRU - I Completed the Reading and achieved a level of Understanding *before* the start of Wednesday\rsquo{}s class and recorded questions about the items I didn\rsquo{}t understand.
	+ PFP - I was present for and attentive to the presentation for this date.
	+ CDL - I fully participated in the Class Directed Learning for this date.
	+ SAQ - I submitted /at least one/ appropriate, Significant, Actual Question I have regarding the information for this week.
	+ PAQ - I was Present for and Attentive to the Answer Questions presentation for this date.
	+ PPL - I, individually, correctly completed this Percentage of the Problems and exercises proving this Level of understanding before Friday at Midnight.

#+Begin_Latex
\pagebreak
#+End_Latex

* Portfolio
** Course Tracker
You are required to track your progress in the course using this table.

Note: Currently, you see full credit for week one\rsquo{}s work. (\checkmark means yes. Blank
means no.) Update the table for week 2 and all subsequent weeks each class day
and week during the semester.

| / |   <> | <>  | <>  | <>  | <>  | <>  | <>  |   <> |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # | Week | CRU | PFP | CDL | SAQ | PAQ | CDL |  PPL |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    1 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    2 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    3 | \check   | \check   | \check   | \check   | \check   | \check   |  85% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    4 | \check   | \checkmark   | \checkmark   | \check   | \checkmark   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    5 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    6 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    7 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    8 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    9 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |   10 | \check   | \check   | \check   | \check   | \check   | \check   |  80% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |   11 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |   12 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |   13 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|

This is an honest and true record of my work for this course.

#+Begin_Latex
\vspace{1in}
#+End_Latex

Signature: @@latex:\underline{\makebox[4in]{}}@@

#+Begin_Latex
\pagebreak
#+End_Latex


* Grade Claims

On the week indicated, bring this updated document to my office and make your claim.

| / | <>         | <>          | <>               | <>             |
|---+------------+-------------+------------------+----------------|
| # | Claim Week | Grade Claim | Instructor Grade | Adjusted Grade |
|---+------------+-------------+------------------+----------------|
| # | 5          | A           | A                | A              |
|---+------------+-------------+------------------+----------------|
| # | 9          | A           | A                | A              |
|---+------------+-------------+------------------+----------------|
| # | 13 - 14    | A           |                  |                |
|---+------------+-------------+------------------+----------------|

#+Begin_Latex
\pagebreak
#+End_Latex

* Evidences

Fill in your evidences here each week to build your portfolio.
The number of pieces of evidence are determined by you. However,
the more you have the better off you will be.

#+Begin_Latex
\pagebreak
#+End_Latex


** Week 1 :noexport:

*** Initial Take Home Exam
    I have included another copy of my Initial Take Home Exam.


#+Begin_Latex
\pagebreak
#+End_Latex


** Week 2 :noexport:
   Selections from Chapter 2 Exercises

*** Exercises 2.1.3: Language Operations
**** 1.
    No, it cannot. Our definition of an alphabet is /finite/ and /non-empty/ set
    of symbols. While /Nat/ may be a /non-empty/ set, it's cardinality is \aleph_0
    (infinite).
**** 2.
    /symbols/ = {"H", "e", "l", "o", " ", "t", "h", "r", "!" } The smallest
    alphabet underlying this string would be the set /symbols/. It meets our
    definition of an alphabet; a finitie and non-empty set.
**** 3.
    While perhaps not every palindrome string is initially created using a
    concatenation of a string with its reverse, any palindrome could certainly
    be defined that way.

*** Exercises 2.1.4: Zero, One, Exp
**** 1.
    /s/ = /abacaca/
    number of /a/'s = 4
    number of /b/'s = 1
    number of /c/'s = 2

    s^4 = abacacaabacacaabacacaabacaca
    number of /a/'s = 4 * 4 = 16
    number of /b/'s = 1 * 4 = 4
    number of /c/'s = 2 * 4 = 8
    number of /d/'s = 0 * 4 = 0
**** 2.

    The /One/ element would be the Universal set (or as we defined it, /Nat/).
    The intersection of any subset with it's parent set would return just the
    subset, aka the /One/ element in multiplication.

    s \cap /Nat/ = s  \cong  s \cap /One/ = s

    The /Zero/ element would be the empty set (\empty). The intersection of any set
    with the empty set returns the empty set. This behaves the same way as the
    /Zero/ element in multiplication.

    s \cap \empty = \empty  \cong  s \cap /Zero/ = /Zero/

*** Exercises 2.2: Languages
**** 1.
    As we've defined language, it must equal the empty set (\empty) or possibly
    infinite set of finite strings which must meet the constraint
         /a^{i}b^j : i,j \ge 0, and i < j.

   This means our language either has /no/ strings (\epsilon is a string, albiet empty)
   OR the string must match the contraints. The constraints specify that the
   number of /i's/ and /j's/ must be greater than or equal to zero AND that
   there are less /b's/ than /a's/.

   For those constraints to be valid, there
   must always be at least 1 /b/, meaning that \epsilon would never be a valid string
   in our language.
**** 2.
   For \epsilon to be a valid string in this language, we would need to modify second
   part of the condition. If we change the condition to be
         /a^{i}b^j : i,j \ge 0, and i \le j/
   \epsilon would be a valid string in our language (note: change /i < j/ to /i \le j/)

*** Exercises 2.2: Languages- Python
**** 1.
#+begin_src python :results output
substrings_s = { "a" * i + "b" * j + "c" * k for i in range(2) for j in range(2) for k in range(2) }
print(substrings_s)
#+end_src

#+RESULTS:
: set(['', 'a', 'c', 'b', 'abc', 'bc', 'ac', 'ab'])

#+begin_src elisp :results raw
(-flatten (loop for i from 0 to 1
      collect (loop for j from 0 to 1
          collect (loop for k from 0 to 1
              collect (concat (make-string i ?a) (make-string j ?b) (make-string k ?c))))))
#+end_src

#+RESULTS:
( c b bc a ac ab abc)

**** 2.

#+begin_src python :results output
print({"(" * i + ")" * j for i in range(6) for j in range(6) if i == j})
#+end_src

#+RESULTS:
: set(['', '(())', '((()))', '()', '((((()))))', '(((())))'])

#+begin_src elisp :results raw
(-flatten
    (loop for i from 0 to 5
        collect (loop for j from 0 to 5
            if (= i j)
            collect (concat (make-string i ?\() (make-string j ?\)))))))

#+end_src

#+RESULTS:
( () (()) ((())) (((()))) ((((())))))

**** 3.

#+begin_src python :results output
p = "abcde"
q = "fghij"

print((p+q)[::-1])
print(q[::-1] + p[::-1])
#+end_src

#+RESULTS:
: 14
: jihgfedcba
: jihgfedcba

On the left side of the equation, we are adding the strings /p/ and /q/ and then
reversing that concatenated string. On the right side of the equation, we are
reversing the strings /p/ and /q/ and then adding them together. This works due
to the commutative property of reverse function. In integer arithmetic, we can
see this same property like so.

Given an three integers /a/, /b/, and /c/:
 (a + b)(c) = (a * c) + (b * c)


#+begin_src python :results output
a = 5
b = 3
c = 2

print((a+b)*(c))
print((a * c) + (b * c))
#+end_src

#+RESULTS:
: 16
: 16

**** 4.
    L_1 describes a language that contains pairs of opposing balanced parantheses
    and the empty string. By opposing balanced parantheses, I mean that the
    string is equally split with all of the opening parentheses on the left side
    of the string, and the closing parentheses on the right (e.g. '()' '(())'
    '((()))' '(((())))' '((((()))))')

    L_2 describes all strings that contain a balanced set of parentheses. This
    means there always an opening parenthesis which precedes a matching closing
    parenthesis. There may be nested pairs of opening and closing parentheses,
    but every opening parenthesis has a matching closing parenthesis and vice
    versa. (e.g. '()' '(())' '(()())')

    L_1 \subset L_2.

    L_3 describes all strings with an equal number of opposing parentheses. The
    opening and closing parentheses are not required to be balanced. The string
    is valid as long as there is the same number of opening as closing parentheses.
    (e.g. '()' '(())' '()()()' '))()((')

    L_1 \sub L_2 \sub L_3

*** Exercises 2.2.5: Languages(review)
**** 1.
    \Sigma = {0,1}

    a. \Sigma^2 = {00, 01, 10, 11}

    b. \Sigma^0 = {\epsilon} (see pg 24)

    c. \Sigma^1 = {0, 1}

    d. \Sigma^3 = {000, 001, 010, 011, 100, 101, 110, 111}
**** 2.
    M = {0, 10}

    a. M^2 = {00, 010, 100, 1010}

    b. M^0 = {\epsilon} (see pg 24)

    c. M^1 = {0, 10}

    d. M^3 = {000, 0010, 0100, 01010, 1000, 10010, 10100, 101010}
**** 3.
    #+begin_src elisp :results silent
(defun l-1 (n)
   (-flatten
      (loop for i from 0 to n
            collect (loop for j from 0 to n
                       if (= i j)
                       collect (concat (make-string i ?\() (make-string j ?\))))))))
#+end_src

#+BEGIN_SRC elisp
(l-1 3)
#+END_SRC

#+RESULTS:
|   | () | (()) | ((())) |

    a. \epsilon, '()', '(())'

    b. '()()()'

    c. '()'.

       We previously established that L_1 \sub L_2 \sub L_3,
       so we would need to take the smallest member of L_1. We could
       go with \epsilon, but that seemed a little too much of a given :)

*** Exercises 2.2.6
**** 1.
     a. L_1 \cup L_2 would match L_2 because L_1 \sub L_2

     b. L_1 \cup L_3 would match L_3 because L_1 \sub L_3

     c. L_1 \cap L_2 would match L_1 because L_1 \sub L_2

**** 2.
     a. star({0, 1}, 2) = {\epsilon, 0, 1, 00, 01, 10, 11}

     b. star({0, 1}, 0) = {\epsilon}

     c. star({0, 1}, 1) = {\epsilon, 0, 1}

     d. star({0, 1}, 3) = {\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, 101, 110, 111}

     e. star({0, 10}, 2) = {\epsilon, 0, 10, 00, 010, 100, 1010}

     f. star({0, 10}, 0) =  {\epsilon}

     g. star({0, 10}, 1) = {\epsilon, 0, 10}

     h. star({0, 10}, 3) = {\epsilon, 0, 10, 00, 010, 100, 1010, 000, 0010, 0100, 01010, 1000, 10010, 10100, 101010}

     i. star({0, 1, 00, \epsilon}, 2) = {\epsilon, 0, 1,00, 01, 000, 10, 11, 100, 001, 0000}

     j. star({0, 10}, 0) = {\epsilon}

     k. star({0, 10}, 1) = {\epsilon, 0, 10}

     l. star({0, 10}, 3) = {\epsilon, 0, 10, 00, 010, 100, 1010, 000, 0010, 0100, 01010, 1000, 10010, 10100, 101010}

     m. It is \sum_0^n 2^n. The size of each set which results from L^n = 2^n. Because /star/ unions these sets together,
        we some the cardinalities of each exponentiated set to find the total number of items

     n. An arbitrary string that is finite/infinite and each symbol in the string is a combintation of the characters 1 or 0

*** Exercises 2.3: Slippery Concepts
**** 1.
     L_E = {0^{2i} : i \ge 0} each string character will be 2i characters long. 2 times
     any number will always result in an even number, thus every string produced
     by this constraint will also be even
**** 2.
     (00) = 0^2 so (00)^i = 0^{2i} thus {0^{2i} : i \ge 0} = {(00)^i : i \ge 0}
**** 3.
     L_O - {0^{2i+1} : i \ge 0}
     contains all strings with odd number of characters. So union would be all strings
     of a finite/infinite number of zeros. Is that what {0}^* represents?
**** 4.
     A language which contains all strings beginning with a finite/infinite number of zeros,
     and ending with a finite/infinite number of ones.
**** 5.
     a. They are equal. The only thing that is different is the variable used to represent the exponenent.

     b. They are equal. The first constraint creates a finite/infinite list of zeros, which is multiplied together
        with a finite/infinite list of ones formed by the second contstraint. This is an equivalent definition.

     c. They are equal. Both sets create words with a finite/infinite number of preceding zeros followed by a
        finite/infinite number of ones. Both sets have a cardinality of \aleph_0, so they are equal.

     d. They are not equal. L_4 does not contain \epsilon

     e. Yes. This is a union of L_3 and {\epsilon} (which should already be in L_3) so we've already established that they are
        the same.

     f. Yes. Although the variable names have changed, they are fixed to be equal to each other, rendering the same result
**** 6.
     No. as L_7 is defined, i and j can be different values, which allows there to be unequal numbers of ones and zeros.
     {0^i : i \ge 0}{1^i : i \ge 0} is using the samve value, which means there will always be an equal number of ones and zeros.
**** 7.
     a. No, it is not the true complement of L_6

     b. 10, 110, 11100000, 1010101

     c. Any string with a 1 coming before a 0.
        Any string with alternating 1's and 0's.
        [{1^{j}0^i}: i, j > 0]
        [{w : w \in ({0}^i {1}^j)^n, i,j,n > 0)

     d. No, L_8 \sub 'L_6


#+Begin_Latex
\pagebreak
#+End_Latex


** Week 3 :noexport:
I was quite ill this week which is why I was not able to complete all of the
exercises. Once my schedule has settled down a bit, I plan on going back and
completing the ones I skipped. Even though I did not complete all of the
exercises, I did leave the chapters confident I understood all of the material
well enough to apply it in future problems.

Selections from Week 3 exercises:

*** Exercise 3.2: Star Properties
**** 1.
    { \epsilon, "((((((", ")))))))", "()()()()" ")))(((", "()())()(" }
**** 2.

     Yes. {0}* indicates the set of all strings of only repeating zeros. Concated
     to that is {1}* which is the set of all strings of only repeating ones. This
     is equivalent to the definition of L_7
**** 3.
     The Empty Language where L_1 * = Unit language

     The Unit Language, where L_2 * = Unit language
**** 4.

***** Languages in English
     L_P0: All binary strings.

     L_P1: All binary strings which are palindromes.

     L_P2: All binary strings with some word and it's reverse split by either a 1,0, or empty string.

     L_P3: All binary strings made up by word and it's reverse split by either a 1 or a 0.

     L_WW: All binary strings made up of a word and it's copy without any modification.

***** Solutions
     Context-free:

     L_P1: It produces the language of all palindromes over the alphabet
     {0,1}, which is context-free

     Context-sensitive:

     L_ww: Produces the language of all words with a pattern of 0's and 1's up to some length
     which is then followed by a carbon copy of the same pattern without any reversal.

     L_P2: Produces the language of a word w followed by a 1,0, or empty string
     which is in turn followed by the reverse of w

     L_P3: Produces the language of a word w followed by a 1,0 which is in turn followed by the reverse of w.


**** 5.
     a. Yes. L_E defines the language containing all strings of a repeated even number of 0's
        L_O defines the language containing all strings of a repeated odd number of 0's. L_E \cup L_O
        would then contain all strings of repeated 0's. This is also the definition {0}*.

     b. Yes. L = LL indicates that a language is the same when concatenated with itself.
        This would be possible with L_E. Concatenating strings of even length will result in
        even lengthed strings. L_E contains all even lengthed strings of repeated 0's, so it would
        equal itself when concatenated with itself.

     c. I believe that L_E = L_E^*. Both contain the empty string, and concatenating two strings of an even number of zeros
        will result in another string of even zeros.

     d. No.

        i. {\empty}

        ii. {\epsilon}

     e. No. L_E^* would only contain strings of zeros which are even in length.

     f. No.

**** 6.

     Claim L* = L*^*

     For every language M, M \sube M*, thus L^* \sube (L^*)^*.

     If w \in (L*)* then w = w_1... w_x for some w_1..., w_x \in L*.

     Then for each i, w_i = w_{i,1}...w_{i,x} where w_{i,j} \in L.

     Then w = w_{1,1}...w_{1,x_1}...w_{x,1} ... w_x,x_x \in L*

     Therefore, (L*)* \sube L*

     This can therefore be represented as L(*)* = L*

*** Exercise 3.4.1: Language Puzzles
    1.
       a. L_x is the subset of {a,b,c}* where each s \in L_x has the same number of
       a, b, and c, and is arranged in alphabetical order.

       b. L_x = {a^{i}b^{i}c^{i} : i \gt
       0 }

       c. L_y is the subset of {a,b,c}* where each s \in L_y begins with 0 or
       more c, followed by 1 or more a or b, followed by 0 or more c, followed
       by 1 or more a or b, and ending with 0 or more c.

*** Exercise 3.5: Homomorphism
    1.
        Yes. It meets both conditions. The reversal of \epsilon is \epsilon. And given strings a
        and b, rev(ab) = rev(a)rev(b).

    2.
         No. function /f/ would not meet condition two. If f(ab) = c and f(a)f(b) = de,
         then f(ab) \ne f(a)f(b) so it is not a homomorphism.

*** Exercise 3.6: Lexicographic Order
 First Python, then elisp :)

 #+begin_src python :results output
   from itertools import product

   def lexlt(s, t):
       if (s==""):
           return True
       if (t==""):
           return False
       if (s[0] < t[0]):
           return True

       return (s[0] == t[0]) & lexlt(s[1::], t[1::])

   L1 = {"abacus", "bandana", "pig", "cat", "dodo", "zulu", "physics"}
   L2 = {"dog", "zebra", "zzxyz", "pimento"}

   def list_pairs(L1, L2):
       prod = list(product(L1, L2))
       filtered_pairs = set(filter(lambda s: lexlt(s[0], s[1]), prod))
       for i in filtered_pairs:
           print(i)

   list_pairs(L1, L2)
 #+end_src

 #+RESULTS:
 #+begin_example
 ('dodo', 'dog')
 ('abacus', 'pimento')
 ('abacus', 'zebra')
 ('abacus', 'zzxyz')
 ('physics', 'zzxyz')
 ('pig', 'pimento')
 ('cat', 'zzxyz')
 ('dodo', 'zzxyz')
 ('abacus', 'dog')
 ('dodo', 'pimento')
 ('physics', 'zebra')
 ('zulu', 'zzxyz')
 ('cat', 'dog')
 ('dodo', 'zebra')
 ('cat', 'zebra')
 ('bandana', 'zzxyz')
 ('bandana', 'dog')
 ('cat', 'pimento')
 ('bandana', 'pimento')
 ('physics', 'pimento')
 ('pig', 'zzxyz')
 ('bandana', 'zebra')
 ('pig', 'zebra')
 #+end_example

 In ELISP!!!! :)
 #+begin_src elisp :results silent
   (defun cartesian-product (x y)
     "Produces the Cartesian product of two lists"
     (mapcan (lambda (x-item)
               (mapcar (lambda (y-item)
                         (if (listp x-item)
                             (append x-item (list y-item))
                           (list x-item y-item)))
                       y))
             x))

   (defun list-pairs (L1 L2)
     (-filter (lambda (pair)
                (string-lessp (car pair) (cadr pair)))
              (cartesian-product L1 L2)))
 #+end_src

 #+begin_src elisp
 (list-pairs
    '("abacus" "bandana" "pig" "cat" "dodo" "zulu" "physics")
    '("dog" "zebra" "zzxyz" "pimento"))
 #+end_src

 #+RESULTS:
 | abacus  | dog     |
 | abacus  | zebra   |
 | abacus  | zzxyz   |
 | abacus  | pimento |
 | bandana | dog     |
 | bandana | zebra   |
 | bandana | zzxyz   |
 | bandana | pimento |
 | pig     | zebra   |
 | pig     | zzxyz   |
 | pig     | pimento |
 | cat     | dog     |
 | cat     | zebra   |
 | cat     | zzxyz   |
 | cat     | pimento |
 | dodo    | dog     |
 | dodo    | zebra   |
 | dodo    | zzxyz   |
 | dodo    | pimento |
 | zulu    | zzxyz   |
 | physics | zebra   |
 | physics | zzxyz   |
 | physics | pimento |


*** Exercise 4.2: DFA Basics
**** 1.

#+NAME: fig:Exercise 4.2 DFA
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 2.0in
     [[file:graphs/4.2dfa.gv.png]]

**** 2.
     State table

     | State | Input | Next State |
     | I     |     0 | A          |
     | I     |     1 | F          |
     | A     |     0 | I          |
     | A     |     1 | I          |
     | F     |     0 | 1          |
     | F     |     1 | 1          |

 It is not so simple as the string must end with a 1. Yes, to exit the state
 machine the string must end with a 1, but there are also rules regarding the
 number of zeros. The string must contain no, or 2+ zeros. The string may not
 contain only one zero.

 I don't think it is possible. There would need to be a way to enforce that
 if a 0 is entered, at least on more is entered as well. I don't think there
 is a way to do that with only a two state DFA.

*** Exercise 4.7.1: Regular or not?
**** 1.
     L_br = { {^i}^i : i \ge 0}

     All strings in L_br must have some number of opening brackets followed by an
     equal number of closing brackets.

***** Steps
     If L is a regular language, then L has a pumping length P such that any
     string S where |S| \ge P may be divided into 3 parts S = xyz such that the
     following conditions must be true:

:     1. xy^{i}z \in L for every i \ge 0
:     2. |y| \gt 0
:     3. |xy| \le P

     Prove that a language is not Regular with pumping Lemma:
     1. Assume that L is regular
     2. It has to have a pumping length P
     3. All strings longer than P can be pumped |S| \ge P
     4. Now find a string 'S' in L such that |S| \ge P
     5. Divide S into x,y,z
     6. Show that xy^{i}z \in L for some i
     7. Consider all ways that S can be divided into x, y, z.

***** Proof setup
     Proof:

     Assume L_br is regular with pumping length P.

     let S = {^p}^p

     let P = 3

     If P = 3, then S = '{{{}}}'

     Case 1: y contains only '{'
             x = '{', y = '{{', z = '}}}'

     Case 2: y contains only '}'
             x = '{{{', y = '}}', z = '}'

     Case 3: y contains both '{' and '}'
             x = '{{', y = '{}', z = '}}'

***** Case 1
      let i = 2
      xy^{i}z \rarr xy^{2}z then \rarr '{{{{{}}}'

****** Condition 1
       xy^{i}z \in L for every i \ge 0

      This string does not belong to L_bc as there are more opening brackets than
      closing brackets.

      if L_br = { {^j}^j : j \ge 0} and S = xy^{2}z = '{{{{{}}}', then S is not \in L_bc

****** Condition 2
       |y| > 0

       |y| = 4. This condition is met

****** Condition 3
       |xy| \le P

       |xy| = 5
       P = 3

       This condition is not met
***** Case 2
      let i = 2
      xy^{i}z \rarr xy^{2}z then \rarr '{{{}}}}}'

****** Condition 1
       xy^{i}z \in L for every i \ge 0

      This string does not belong to L_bc as there are more closing brackets than
      opening brackets.

      if L_br = { {^j}^j : j \ge 0} and S = xy^{2}z = '{{{}}}}}}', then S is not \in L_bc

****** Condition 2

       |y| > 0
       |y| = 4

       This condition is met

****** Condition 3
       |xy| \le P

       |xy| = 5
       P = 3

       This condition is not met
***** Case 3
      let i = 2
      xy^{i}z \rarr xy^{2}z then \rarr '{{{}{}}}'

****** Condition 1
       xy^{i}z \in L for every i \ge 0

     This string does not belong to L_bc as it does not follow the pattern of any
     number of opening brackets followed by the same number of closing brackets.


     if L_br = { {^j}^j : j \ge 0} and S = xy^{2}z = '{{{}{}}}', then S is not \in L_bc

****** Condition 2
       |y| > 0
       |y| = 4
       This condition is met
****** Condition 3
       |xy| \le P

       |xy| = 5
       P = 3

       This condition is not met
***** Conclusion
      For every given partition of xyz, all three conditions of a regular language are not met.
      Therefore, L_bc is not a regular language by proof of contradiction using the pumping lemma.
#+Begin_Latex
\pagebreak
#+End_Latex



**** 2.
     #+NAME: fig:Exercise 4.7.1.2 DFA
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 2.0in
            [[file:graphs/dfa4.7.1.2.gv.png]]

#+Begin_Latex
\pagebreak
#+End_Latex



**** 3.
#+NAME: fig:Exercise 4.7.1.2 DFA
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 2.0in
     [[file:graphs/4-7-1-3.png]]
*** Exercise 4.9
    2.
         If L is regular than that implies that there is a natural number N such
         that for any string w \in L where w is at least length of N, we must be able
         to read out w as hmt, were h and t are strings of aribitrary length and m
         is length N and m can be split into strings xyz where y is non-empty and
         xy is confined to the first N steps of m and furthermore, for all i\ge0, xy^i
         z \in L must be true.
    4.
         Original:
:         \exists N \in Nat:
:         \forall w \in L : [|w| \ge N \rarr
:                        \exist x,y,z \in \Sigma^* :
:                             w = xyz
:                         \land   |xy| \le N
:                         \land   y \ne \epsilon
:                         \land   \forall i \ge 0 : xy^{i}z \in L ]
        Negated Condition:
:        \forall N \in Nat:
:        \forall w \in L : [ |w| \ge N \rarr
:                        \forall x, y, z \in \Sigma^*:
:                             w = xyz
:                        \land    |xy| \le N
:                        \land    y \ne \epsilon
:                        \land    \exist i : xy^{i}z \notin L.

#+Begin_Latex
\pagebreak
#+End_Latex


** Week 4 :noexport:
A lot of this week's work was in Jove. I tried to include as much evidence for
the work I did in Jove without actually importing the notebooks. This is shown
in the copied Python code and imported DFA images for some of the exercises.


Selections from Week 4 exercises:


*** Exercise 5.1.1: Equal Change DFA
**** 1.
     It is missing the fact that there must be a strict equal number of
     transitions between 0 \rarr 1 and 1 \rarr 0. Not every string which belongs to the
     alternative definition also belongs to the original definition.
     Also \epsilon is not included in the second language.
**** 2.
#+NAME: fig:Exercise 5.1.1.2 DFA
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 2.0in
 [[file:graphs/5.1.1.2.gv.png]]

     Test Strings
 | String | In | Out | Correct |
 |    010 | \check  |     | \check       |
 |  10101 | \check  |     | \check       |
 |   0111 |    | \check   | \check       |
 |  10100 |    | \check   | \check       |

 This DFA handles the case of the empty string, strings of only 0's or 1's,
 and forces there to be a balanced number of 1 \rarr 0, 0 \rarr 1 switches based on the
 number of states required to pass through to get back to a finish state once a switch
 is made.

*** Exercise 5.2.1: Block-of-3 DFA

**** 1.

     | State | to | New State |
     | S     |  0 | S0        |
     | S0    |  0 | BH        |
     | S0    |  1 | S01       |
     | S01   |  0 | BH        |
     | S01   |  1 | S         |
     | S     |  1 | S1        |
     | S1    |  0 | S10       |
     | S10   |  1 | S         |
     | S10   |  0 | BH        |
     | S1    |  1 | S11       |
     | S11   |  0 | S         |
     | S11   |  1 | BH        |

 #+BEGIN_SRC python
 from graphviz import Digraph

 d = Digraph("5.2.1.1", filename='5.2.1.1.gv', engine='dot', format='png')

 d.attr('node', shape='doublecircle')
 d.node('IF')

 d.attr('node', shape='circle')
 d.node('BH')
 d.node('S0')
 d.node('S1')
 d.node('S01')
 d.node('S10')
 d.node('S11')

 d.edge('IF', 'S0', label='0')
 d.edge('S0', 'BH', label='0')
 d.edge('S0', 'S01', label='1')
 d.edge('S01', 'BH', label='0')
 d.edge('S01', 'IF', label='1')
 d.edge('IF', 'S1', label='1')
 d.edge('S1', 'S10', label='0')
 d.edge('S10', 'IF', label='1')
 d.edge('S10', 'BH', label='0')
 d.edge('S1', 'S11', label='1')
 d.edge('S11', 'IF', label='0')
 d.edge('S11', 'BH', label='1')
 d.edge('BH', 'BH', label='1')
 d.edge('BH', 'BH', label='0')
 d
 #+END_SRC
#+NAME: fig:Exercise 5.2.1.1 DFA
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 2.0in
 [[file:graphs/5.2.1.1.gv.png]]

 Treat every string as if it is a 3 bit word. We know that the valid 3 bit strings are
 011, 110, 101. Make paths for these strings, and send anything else to the black hole.

**** 2.
 The complement of L_b3 would be 'L_bc = { x: Every contiguous block of 3 bits in x
 must have > or < than 2 1s.

 | State | New State | to |
 | IF    | S0        |  0 |
 | S0    | S0        |  0 |
 | S0    | S01       |  1 |
 | S01   | BH        |  1 |
 | S01   | S010      |  0 |
 | S010  | IF        |  0 |
 | S010  | BH        |  1 |
 | IF    | S1        |  1 |
 | S1    | BH        |  1 |
 | S1    | S10       |  0 |
 | S10   | BH        |  1 |
 | S10   | IF        |  0 |
 | BH    | BH        |  0 |
 | BH    | BH        |  1 |

 #+BEGIN_SRC python
 from graphviz import Digraph

 d = Digraph("5.2.1.2", filename='5.2.1.2.gv', engine='dot', format='png')

 d.attr('node', shape='doublecircle')
 d.node('IF')

 d.attr('node', shape='circle')
 d.node('BH')
 d.node('S0')
 d.node('S01')
 d.node('S010')
 d.node('S1')
 d.node('S10')

 d.edge('IF', 'S0', label='0')
 d.edge('S0', 'S00', label='0')
 d.edge('S00', 'IF', label='0')
 d.edge('S00', 'S001', label='1')
 d.edge('S001', 'S010', label='0')
 d.edge('S001', 'BH', label='1')
 d.edge('S0', 'S01', label='1')
 d.edge('S01', 'BH', label='1')
 d.edge('S01', 'S010', label='0')
 d.edge('S010', 'IF', label='0')
 d.edge('S010', 'BH', label='1')
 d.edge('IF', 'S1', label='1')
 d.edge('S1', 'S11', label='1')
 d.edge('S11', 'IF', label='1')
 d.edge('S11', 'BH', label='0')
 d.edge('S1', 'S10', label='0')
 d.edge('S10', 'BH', label='1')
 d.edge('S10', 'IF', label='0')
 d.edge('BH', 'BH', label='0')
 d.edge('BH', 'BH', label='1')
 d.view()


 #+END_SRC
#+NAME: fig:Exercise 5.2.1.2 DFA
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 2.0in
 [[file:graphs/5.2.1.2.gv.png]]

**** 3.

     I followed the same process, but it was much quicker now that I knew what I
     was looking for. I just plotted out the different state switches that would
     happen, and built the DFA from that.



*** Exercise 6.2: DFA Jove \cup, \cap
**** 1.
 Complement:

 #+begin_src python
   DFA_fig47_comp = {'Q': {'A', 'B', 'IF'},
    'Sigma': {'0', '1'},
    'Delta': {('IF', '0'): 'A',
     ('IF', '1'): 'IF',
     ('A', '0'): 'B',
     ('A', '1'): 'A',
     ('B', '0'): 'IF',
     ('B', '1'): 'B'},
    'q0': 'IF',
    'F': {'A', 'B'}}
 #+end_src

 Union of complement and base:
#+NAME: fig:Exercise 6.2.1 DFA
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 2.0in
 [[file:graphs/union47_comp47.png]]

 Yes, this is still a DFA. A DFA is allowed to have disconnected states.
**** 2.
     It begins from the initial state and moves through every state transition in
     the language for each state it comes ac. It then constructs a new DFA from
     only the states it encountered, removing all of the unreachable, and
     therefore unneeded states.

*** Exercise 6.5: DFA, DeMorgan's Laws
**** 1.

     The isomorphic property indicates that not only are two DFA language
     equivalent, but that they have the same number of states. Two DFA can be
     language equivalent without being isomorphic. Take for instance, a bloated
     and minimal DFA for a given language. Although the two DFA are language
     equivalent, they are not isomorphic because they do not have the same number
     of states. The bijection mentioned in Myhill-Nerod Theorem is a byproduct of
     the isomorphic nature of language equivalent minimal DFA and being able to
     map a minimal DFA state-to-state with its isomorphic sibling. Therefore, if
     two DFA are not isomorphic to each other, they will not have a bijection
     even if they are language equivalent.

**** 2.

     #+begin_example
 DFA_6.5.2 = {

    I       : 0 -> I
    I       : 1 -> S1
    S1      : 0 -> S10
    S1      : 1 -> I
    S10     : 0 -> S10
    S10     : 1 -> S101
    S101    : 0 -> S1010
    S101    : 1 -> S01
    S1010   : 0 -> I
    S1010   : 1 -> F10101
    F10101  : 0 -> S10
    F10101  : 1 -> I

 }
     #+end_example
**** 3.

***** Check intersection:
     |    String | In Language | Accepted? | Correct? |
     |     10101 | \check           | \check         | \check        |
     |    110101 | \empty           | \empty         | \check        |
     |   1000101 | \check           | \check         | \check        |
     | 111000101 | \check           | \check         | \check        |
     |    100000 | \empty           | \empty         | \check        |
     |  00000101 | \empty           | \empty         | \check        |

***** Using Tools:

      Done in Jove
**** 4.

     #+begin_example
     DFA_oa = {
        I : a -> F
        I : b -> I
        F : a -> I
        F : b -> I
     }


     DFA_eb = {
        IF : a -> Sa
        IF : b -> IF
        Sa : a -> IF
        Sa : b -> Sa
     }
     #+end_example

     D_ea \cup D_ob = (D_oa \cap D_eb)^c

     Steps followed in Jove:

     #+begin_example
     inter_Doa_Deq = intersect_dfa(DFA_oa, DFA_eb)

     comp_inter_Doa_Deq = comp_dfa(inter_Doa_Deq)

     min_comp_inter_Doa_Deq = min_dfa(comp_inter_Doa_Deq)

     iso_dfa(min_comp_inter_Doa_Deq, union_dfa(comp_dfa(D_oa), comp_dfa(D_eq)))

     # True
     #+end_example
**** 5.

     |    | I1 | F2 | F3 | S8 | S5 | S7 | S4 | F6 | F9 |
     | I1 | x  | x  | x  | x  | x  | x  | x  | x  | x  |
     | F2 | \check  | x  | x  | x  | x  | x  | x  | x  | x  |
     | F3 | \check  | -  | x  | x  | x  | x  | x  | x  | x  |
     | S8 | +  | \check  | \check  | x  | x  | x  | x  | x  | x  |
     | S5 | +  | \check  | \check  | -  | x  | x  | x  | x  | x  |
     | S7 | +  | \check  | \check  | -  | -  | x  | x  | x  | x  |
     | S4 | +  | \check  | \check  | -  | -  | -  | x  | x  | x  |
     | F6 | \check  | +  | +  | \check  | \check  | \check  | \check  | x  | x  |
     | F9 | \check  | +  | +  | \check  | \check  | \check  | \check  | -  | x  |


     | Pair   | Input | Output         | Marked? |
     | I1, S8 | a     | F2, F6         | Yes     |
     | I1, S5 | a     | F2, F6         | Yes     |
     | I1, S7 | a     | F2, F6         | Yes     |
     | I1, S4 | a     | F2, F6         | Yes     |
     | F2, F3 | a     | S8, S7         | No      |
     | F2, F3 | b     | S5, S4         | No      |
     | S5, S8 | a,b   | F6, F6, F6, F9 | No      |
     | S7, S8 | a     | F6, F6         | No      |
     | S7, S8 | b     | F6, F9         | No      |
     | S7, S5 | a,b   | F6, F6         | No      |
     | S4, S8 | a     | F6, F6         | No      |
     | S4, S8 | b     | F6, F9         | No      |
     | S4, S5 | a,b   | F6, F6         | No      |
     | S4, S7 | a,b   | F6, F6         | No      |
     | F6, F2 | a     | F6, S5         | Yes     |
     | F6, F3 | a     | F6, S7         | Yes     |
     | F9, F2 | a     | F9, S8         | Yes     |
     | F9, F3 | a     | F9, S7         | Yes     |
     | F9, F6 | a     | F9, F6         | No      |
     | F9, F6 | b     | F6, F6         | No      |


     Combine:
     (F3, F2), (S5, S8), (S7, S8), (S7, S5), (S4, S8), (S4, S5), (S4, S7), (F9, F6)


 :
 :      a      *    a                a      *
 :  I1 --->  F2_F3 ---> S4_S5_S7_S8 --->  F6_F9 --
 :      b      *    b                b      * ^  |  a
 :                                            |__|  b


     Output from Jove:

#+NAME: fig:Exercise 6.5.5 DFA
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 2.0in
 [[file:graphs/Chapter6BlimpMin.png]]



#+Begin_Latex
\pagebreak
#+End_Latex


** Week 5 :noexport:
*** Chapter 7 Exercises [100%]
**** DONE Exercise 7.5: NFA to DFA
     CLOSED: [2019-02-08 Fri 13:46]
***** 1.

  #+BEGIN_EXAMPLE
  NFA
  I    : 0|1   -> I
  I    : 0|''  -> S0
  S0   : 1     -> S01
  S01  : 0     -> S010
  S010 : 1     -> F
  F    : 0|1   -> F
  #+END_EXAMPLE

  #+BEGIN_SRC python
  strings = ["{0:b}".format(i).zfill(4) for i in range(0, 20)]
  accepts = ["accepts" if accepts_nfa(nfa7_5, s) else "rejects" for s in strings]
  list(zip(strings, accepts))
  #+END_SRC

***** 2.
      A.
      Define language described in 5.2.1 in formal terms:
      L = {w : \in \Sigma^* :
               \forall x \in {p \in parts(w): len(p) = 3 } :
                    count(x, 1) = 2 }

     Any word w in {0,1}* where for all partitions of w with length 3 have exactly two 1's.

      Negated:
      L = {w: \in \Sigma^*:
            \exists x \in {p \in parts(w): len(p) = 3} :
               count(x, 1) != 2 }

     Any word w wherin exists a partition x of length three which does not have exactly two 1's

     So yes, this is a correct negation.
      B.

  #+BEGIN_SRC python
  complement_of_blocks_of_3 = md2mc('''
  NFA
  I : 0 -> I
  I : 1 -> I
  I : 0 -> S0
  I : 1 -> S1
  S0 : 0 -> S00
  S0 : 1 -> S01
  S1 : 0 -> S10
  S01 : 0 -> F
  S10 : 0 -> F
  S00 : 0 -> F
  S00 : 1 -> F
  F : 0 -> F
  F : 1 -> F
  ''')
  dotObj_nfa(complement_of_blocks_of_3)
  #+END_SRC

  #+BEGIN_SRC python
  dotObj_dfa(min_dfa(comp_dfa(min_dfa(nfa2dfa(complement_of_blocks_of_3)))))
  #+END_SRC

      C.

  #+BEGIN_SRC python
  nums = []
  it = 1
  while len(nums) < 20:
    for i in itertools.product([0,1],repeat=it):
      nums.append(i)
    it += 1
  values = []
  for each in nums:
    word = ""
    for i in each:
      word += str(i)
    values.append(word)
  for each in values:
      print("String: ", each, " Accepted NFA: ", accepts_nfa(complement_of_blocks_of_3, each), " Accepted DFA: ", accepts_dfa(blocks_of_3_dfa, each))
  #+END_SRC
***** 3

  Worked on it with Daniel, Matt, Seth. Couldn't figure it out.
**** DONE Exercise 7.6.1: Brzozoski's DFA minimization
     CLOSED: [2019-02-08 Fri 18:25]
***** 1.
  Beginning DFA
  #+BEGIN_SRC python
  bloated_dfa = md2dc('''
  DFA
  IS1 : a -> FS2
  IS1 : b -> FS3
  FS2 : a -> S4
  FS2 : b -> S5
  FS3 : a -> S5
  FS3 : b -> S4
  S4 : a | b -> FS6
  S5 : a | b -> FS6
  FS6 : a | b -> FS6
  ''')
  #+END_SRC

  Reverse turning it into an NFA
  #+BEGIN_SRC python
  rev_bloated_nfa = md2mc('''
  NFA
  IS6 : a | b -> IS6
  IS6 : a | b -> S4
  IS6 : a | b -> S5
  S4  : a -> IS2
  S4  : b -> IS3
  S5  : a -> IS3
  S5  : b -> IS2
  IS2 : a -> FS1
  IS3 : b -> FS1
  ''')
  #+END_SRC

  Turn NFA into DFA
  #+BEGIN_SRC python
  rev_bloated_dfa = md2mc('''
  DFA
  IS0 : a | b -> FS1
  FS1 : a | b -> S2
  S2  : a | b -> FS3
  FS3 : a | b -> FS3
  ''')

  #+END_SRC

  Reverse reversed DFA
  #+BEGIN_SRC python
  min_nfa = md2mc('''
  NFA
  IS1 : a | b -> IS1
  IS1 : a | b -> S2
  S2 : a | b -> IS3
  IS3 : a | b -> FS4
  ''')
  #+END_SRC

  Convert back to dfa
  #+BEGIN_SRC python
  min_dfa = md2mc('''
  DFA
  IS0 : a | b -> FS1
  FS1 : a | b -> S2
  S2 : a | b -> FS3
  FS3 : a | b -> FS3
  ''')
  #+END_SRC
***** 3.
  #+BEGIN_SRC python
  blimp = md2mc('''
  DFA
  I1 : a -> F2
  I1 : b -> F3
  F2 : a -> S8
  F2 : b -> S5
  F3 : a -> S7
  F3 : b -> S4
  S4 : a | b -> F6
  S5 : a | b -> F6
  F6 : a | b -> F6
  S7 : a | b -> F6
  S8 : a -> F6
  S8 : b -> F9
  F9 : a -> F9
  F9 : b -> F6
  ''')
  min1 = min_dfa(blimp)
  min2 = min_dfa_brz(blimp)
  iso_dfa(min1, min2)
  #+END_SRC

  True

*** Chapter 8 Exercises [100%]
**** DONE Exercise 8.2: NFA Operations
     CLOSED: [2019-02-08 Fri 19:18]
***** 1.
  001100100
  001000101
***** 2.
  #+BEGIN_SRC python
  re_8_5_nfa = md2mc('''
  NFA
  I1 : '' -> St1
  I1 : '' -> St2
  St1 : '' -> I1
  St2 : a -> St3
  St3 : '' -> I1
  IF2 : '' -> St4
  IF2 : '' -> St5
  St4 : c -> St6
  St6 : '' -> St7
  St7 : d -> St8
  St8 : '' -> IF2
  St5 : b -> St9
  St9 : '' -> IF2
  I1 : '' -> IF2
  ''')
  dotObj_nfa(re_8_5_nfa)
  #+END_SRC
***** 3.
  #+BEGIN_SRC python
  re_8_5_nfa = re2nfa("(''+a)*(b+cd)*")
  dotObj_nfa(re_8_5_nfa)

  re_8_5_nfa_hand = md2mc('''
  NFA
  I1 : '' -> St1
  I1 : '' -> St2
  St1 : '' -> I1
  St2 : a -> St3
  St3 : '' -> I1
  IF2 : '' -> St4
  IF2 : '' -> St5
  St4 : c -> St6
  St6 : '' -> St7
  St7 : d -> St8
  St8 : '' -> IF2
  St5 : b -> St9
  St9 : '' -> IF2
  I1 : '' -> IF2
  ''')
  dotObj_nfa(re_8_5_nfa_hand)

  iso_dfa(nfa2dfa(re_8_5_nfa), nfa2dfa(re_8_5_nfa_hand))
  #+END_SRC

  True!
**** DONE Exercise 8.8: Sylvester's Formula
     CLOSED: [2019-02-08 Fri 19:38]
***** 1.
  No. Any linear combination of 3 and 6 will always have to be a multiple
  of three. This means there are infinitely many natural numbers which cannot
  be expressed by 3 and 6.
***** 2.

  The requirement that the greatest common divisor (GCD) equal 1 is necessary in
  order for the Frobenius number to exist. If the GCD were not 1, every integer
  that is not a multiple of the GCD would be inexpressible as a linear, let alone
  conical, combination of the set, and therefore there would not be a largest such
  number. For example, if you had two types of coins valued at 4 cents and 6
  cents, the GCD would equal 2, and there would be no way to combine any number of
  such coins to produce a sum which was an odd number. On the other hand, whenever
  the GCD equals 1, the set of integers that cannot be expressed as a conical
  combination of { a1, a2, , an } is bounded according to Schur's theorem, and
  therefore the Frobenius number exists.
  - Wiki
**** Exercise 8.8.5: Postage Stamp
***** 1.
     a. p,q = 5, 11
        F(p,q) = (5*11) - 5 - 11 = 55 - 5 - 11 = 39
     b.
        p,q = 5,1
        F(p,q) = 39
        p,q,r = 5,7,11
        F(p,q,r) = 13

***** 2.


** Week 6 :noexport:
*** Monday, Feb 11
**** CDL

  #+BEGIN_SRC dot :file cdlFeb11.png
  digraph {
	  graph [rankdir=LR]
	  EMPTY [label="" shape=plaintext]
	  S2 [label=S2 peripheries=1 shape=circle]
    B [label=B peripheries=1 shape=circle]
    E [label=E peripheries=2 shape=circle]
	  IF1 [label=IF1 peripheries=1 shape=circle]
	  F3 [label=F3 peripheries=1 shape=circle]
    EMPTY -> B
	  B -> IF1 [label=""]
	  IF1 -> S2 [label=a]
	  IF1 -> S2 [label=b]
	  S2 -> S2 [label=a]
	  S2 -> F3 [label=b]
	  F3 -> IF1 [label=a]
	  F3 -> S2 [label=b]
    IF1 -> E [label=""]
    F3 -> E [label=""]
  }
  #+END_SRC

  #+RESULTS:
  [[file:cdlFeb11.png]]




*** Chapter 9 [100%]
**** DONE Exercise 9.2: NFA to RE
     CLOSED: [2019-02-13 Wed 20:29]
***** 1.
  Deleting the "X" state last produced the smaller regular expression. This is due
  to the nature of how states are removed from the NFA. If we remove the "busy"
  state last, then most of the states leading to it have already been collapsed,
  leading to less states needing to be collapsed in the final iteration.
****** a.
  Delete Order:
  #+BEGIN_EXAMPLE
  ["I1", "I2","I3", "F1","F2", "X"]
  #+END_EXAMPLE

  Produced Regex:
  #+BEGIN_EXAMPLE
  '(((c + ((b + a) + a)) + ((b + a) + a)) (((p + q))* ((n + m) + m)))'
  #+END_EXAMPLE

  Delete Order

****** b
  Delete order:
  #+BEGIN_EXAMPLE
  ["X", "I1", "I2", "I3", "F1", "F2"]
  #+END_EXAMPLE
  Produced Regex:
  #+BEGIN_EXAMPLE
  '(((((c (((p + q))* n)) + (((b (((p + q))* n)) + (a (((p + q))* n))) + (a (((p + q))* n)))) + (((b (((p + q))* n)) + (a (((p + q))* n))) + (a (((p + q))* n)))) + (((c (((p + q))* m)) + (((b (((p + q))* m)) + (a (((p + q))* m))) + (a (((p + q))* m)))) + (((b (((p + q))* m)) + (a (((p + q))* m))) + (a (((p + q))* m))))) + (((c (((p + q))* m)) + (((b (((p + q))* m)) + (a (((p + q))* m))) + (a (((p + q))* m)))) + (((b (((p + q))* m)) + (a (((p + q))* m))) + (a (((p + q))* m)))))'
  #+END_EXAMPLE

***** 2.
  Heuristically, it seems better to eliminate the busy state last. This is due to
  the reason I explained above. This could perhaps change based on the nfa and the
  number of "busy" states.

***** 3.
  We could always convert them back to an nfa and check for language equivelance.

**** DONE Exercise 9.5: nfa2re: RE Size
     CLOSED: [2019-02-28 Thu 15:04]
***** 1.
  #+BEGIN_SRC python
    md2mc('''
    NFA
    I : '' -> A
    I : '' -> G
    A : '' -> C
    A : '' -> B
    B : 1 -> D
    C : 0 -> E
    D : '' -> G
    E : '' -> A
    E : '' -> G
    G : 1 -> F
    ''')
  #+END_SRC

  Delete Order: I, A, B, C, D, E, G, F.
****** Step 1.
       Add real I (S) and real F (Q)
  #+BEGIN_SRC python
    md2mc('''
    NFA
    S : '' -> I
    I : '' -> A
    I : '' -> G
    A : '' -> C
    A : '' -> B
    B : 1 -> D
    C : 0 -> E
    D : '' -> G
    E : '' -> A
    E : '' -> G
    G : 1 -> F
    F : '' -> Q 
    ''')
  #+END_SRC
  | SI | = | \epsilon |
  | IA | = | \epsilon |
  | IG | = | \epsilon |
  | AB | = | \epsilon |
  | AC | = | \epsilon |
  | BD | = | 1 |
  | CE | = | 0 |
  | DG | = | \epsilon |
  | EA | = | \epsilon |
  | EG | = | \epsilon |
  | GF | = | 1 |
  | FQ | = | \epsilon |

****** Remove I
  i = S, j = a
  R1_a = \epsilon, R2_a = \empty, R3_a = \epsilon, R4_a = \empty
  i = S, j = g
  R1_g = \epsilon, R2_g = \empty, R3_g = \epsilon, R4_g = \empty
  | SA | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | SG | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | AB | = | \epsilon                | = | \epsilon |
  | AC | = | \epsilon                | = | \epsilon |
  | BD | = | 1                | = | 1 |
  | CE | = | 0                | = | 0 |
  | DG | = | \epsilon                | = | \epsilon |
  | EA | = | \epsilon                | = | \epsilon |
  | EG | = | \epsilon                | = | \epsilon |
  | GF | = | 1                | = | 1 |
  | FQ | = | \epsilon                | = | \epsilon |

****** Remove A
  i = S, j = b
  R1_B = \epsilon, R2_B = \empty, R3_B = \epsilon, R4_B = \empty
  i = S, j = c
  R1_C = \epsilon, R2_C = \empty, R3_C = \epsilon, R4_C = \empty
  i = E, j = E
  R1_E = \epsilon, R2_E = \empty, R3_E = \empty, R4_C = \empty
  | SB | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | SC | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | SG | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | BD | = | 1                | = | 1 |
  | CE | = | 0                | = | 0 |
  | DG | = | \epsilon                | = | \epsilon |
  | ES | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | EG | = | \epsilon                | = | \epsilon |
  | GF | = | 1                | = | 1 |
  | FQ | = | \epsilon                | = | \epsilon |

****** Remove B
  i = S, j = D
  R1 = \epsilon, R2 = \empty, R3 = 1, R4 = \empty 
  | SC | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | SD | = | (\epsilon)(\empty)^*(1) \cup (\empty) | = | 1 |
  | SG | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | CE | = | 0                | = | 0 |
  | DG | = | \epsilon                | = | \epsilon |
  | ES | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | EG | = | \epsilon                | = | \epsilon |
  | GF | = | 1                | = | 1 |
  | FQ | = | \epsilon                | = | \epsilon |

****** Remove C
  i = S, j = E
  R1 = \epsilon, R2 = \empty, R3 = 0, R4 = \empty
  | SD | = | (\epsilon)(\empty)^*(1) \cup (\empty) | = | 1 |
  | SE | = | (\epsilon)(\empty)^*(0) \cup (\empty) | = | 0 |
  | SG | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | DG | = | \epsilon                | = | \epsilon |
  | ES | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | EG | = | \epsilon                | = | \epsilon |
  | GF | = | 1                | = | 1 |
  | FQ | = | \epsilon                | = | \epsilon |

****** Remove D
  i = S, j = G
  R1 = 1, R2 = \empty, R3 = \epsilon, R4 = \epsilon 

  | SE | = | (\epsilon)(\empty)^*(0) \cup (\empty) | = | 0 |
  | SG | = | (1)(\empty)^*(\epsilon) \cup (\epsilon) | = | 1 |
  | ES | = | (\epsilon)(\empty)^*(\epsilon) \cup (\empty) | = | \epsilon |
  | EG | = | \epsilon                | = | \epsilon |
  | GF | = | 1                | = | 1 |
  | FQ | = | \epsilon                | = | \epsilon |

****** Remove E
  i = S, j = S
  R1 = 0, R2 = \empty, R3 = \epsilon, R4 = \empty
  i = S, j = G
  R1 = 0, R2 = \empty, R3 = \epsilon, R4 = 1 
  | SS | = | (0)(\empty)^*(\epsilon) \cup (\empty) | = |   0 |
  | SG | = | (0)(\empty)^*(\epsilon) \cup (1) | = | 0+1 |
  | GF | = | 1                | = |   1 |
  | FQ | = | \epsilon                | = |   \epsilon |

****** Remove G
  i = S, j = F
  R1 = 0+1, R2 = \empty, R3 = 1, R4 = \empty
  | SS | = | (0)(\empty)^*(\epsilon) \cup (\empty) | = |   0 |
  |SF| = |(0+1)(\empty)^*(1) \cup (\empty) | = |(0+1)1
  | FQ | = | \epsilon                | = |   \epsilon |

****** Remove F
  i = S, j = Q
  R1 = (0+1)1, R2 = \empty, R3 = \epsilon, R4 = \empty
  | SS | = | (0)(\empty)^*(\epsilon) \cup (\empty)    | = |      0 |
  | SQ | = | (0+1)1(\empty)^*(\epsilon) \cup (\empty) | = | (0+1)1 |

****** Final REGEX
     ((((0 ((0)* ((1 + "") + ""))) + ((1 + "") + "")) + ((1 + "") + "")) 1)

     | SI | = | \epsilon |
     | IA | = | \epsilon |
     | IG | = | \epsilon |
     | AC | = | \epsilon |
     | AB | = | \epsilon |
     | BD | = | 1 |
     | CE | = | 0 |
     | DG | = | \epsilon |
     | EA | = | \epsilon |
     | EG | = | \epsilon |
     | GF | = | 1 |
     | FQ | = | \epsilon |


** Week 7 :noexport:

*** DONE Wednesday, FEB 20, 2019 [100%]
    CLOSED: [2019-02-20 Wed 14:04]

**** DONE Warmup CDL
     CLOSED: [2019-02-20 Wed 13:07]
  the boy sees a flower
  | Noun Phrase  | Verb Phrase  |
  | Complex Noun | Complex Verb |

  | Arcticle | Noun | Verb | Noun Phrase |

  | the | boy | sees | Article | Noun   |
  | the | boy | sees | a       | flower |

  SENTANCE => NOUN-PHRASE VERB-PHRASE

           => COMPLEX-NOUN COMPLEX-VERB

           => ARTICLE NOUN VERB NOUN-PHRASE

           => the boy sees COMPLEX-NOUN

           => the boy sees ARTICLE NOUN

           => the boy sees a flower

**** DONE 2nd Warmup CDL
     CLOSED: [2019-02-20 Wed 13:09]
  a girl with a flower likes the boy
  SENTANCE => NP VP

           => CN PP VP

           => A N P CN CV

           => a girl with A N V NP

           => a girl with a flower likes CN

           => a girl with a flower likes A N

           => a girl with a flower likes the boy

**** DONE 3rd Warmpup CDL
     CLOSED: [2019-02-20 Wed 13:18]

  the girl touches the boy with the flower
  S => NP VP

    => NP CV PP

    => CN V NP P CN

    => CN V CN P CN

    => A N V A N P A N

    => the girl touches the boy with the flower

**** DONE 4th Warmup CDL
     CLOSED: [2019-02-20 Wed 13:32]


  | S -> aB |
  | B -> '' | bbB |
  | B -> bb | bbB |

**** DONE 5th Warmup CDL
     CLOSED: [2019-02-20 Wed 13:32]
     | S -> ''   |
     | S -> aSbb |

**** DONE 6th Warmup CDL
     CLOSED: [2019-02-20 Wed 13:32]

     | S -> \lambda  |
     | S -> B  |
     | B -> bB |
     | B -> \lambda  |

**** DONE REAL CDL
     CLOSED: [2019-02-20 Wed 13:43]

     L = {s : s \in {a, b}^* and #_b (s) = 2#_a (s)}

     | S -> a S b S b |
     | S -> b S a S b |
     | S -> b S b S a |
     | S -> \epsilon         |


**** REAL CDL pt 2

     L = {s : s \in {a, b}^* and #_b (s) = 2#_a (s) + 3}

     | S -> A         |
     | S -> \epsilon         |
     | A -> B b b b   |
     | A -> b B b b   |
     | A -> b b B b   |
     | A -> b b b B   |
     | B -> a B b B b |
     | B -> b B a B b |
     | B -> b B b B a |
     | B -> \epsilon         |

*** DONE Friday, FEB 22, 2019 [100%]
    CLOSED: [2019-02-22 Fri 18:43]
**** DONE CDL
     CLOSED: [2019-02-22 Fri 18:43]

  Build two PDA

  One to recognize the language of EvenPalindromes over \Sigma = {0, 1}, {ww^R : w \in \Sigma }
  (4 states)

  The other to recognize the language of MarkedPalindromes over \Sigma = {0, 1} with #
  as the the *marked* character.

  {w#w^R : w \in \Sigma } (4 states)

  #+BEGIN_EXAMPLE
  I: 0, # : 0# -> A
  I: 1, # : 1# -> A
  A : 0, 0 : 00 -> A
  A : 1, 0 : 01 -> A
  A : 0, 1 : 01 -> A
  A : 1, 1 : 11 -> A
  A : #, 0 : 0  -> B
  A : #, 1 : 1  -> B
  B : 1, 1 : '' -> B
  B : 0, 0 : '' -> B
  B : '', #: # -> F
  #+END_EXAMPLE

*** DONE Chapter 11 Exercises [100%]
    CLOSED: [2019-02-22 Fri 19:50]

**** DONE 11.5.1 [100%]
     CLOSED: [2019-02-20 Wed 21:24]

***** DONE 11.5.1.1
      CLOSED: [2019-02-20 Wed 20:41]
  Sentance 1 + 2 * 3
  #+BEGIN_EXAMPLE
  E -> E+T | T
  T -> T*F | F
  F -> 1 | 2 | 3 | ~F | (E)
  #+END_EXAMPLE

  E => E + T
    => F + T * F
    => 1 + F * 3
    => 1 + 2 * 3

  as parse tree:
:               E
:              /|\
:             E + T
:            /   /|\
:           F   T * F
:           |   |   |
:           1   F   3
:               |
:               2

***** DONE 11.5.1.2
      CLOSED: [2019-02-20 Wed 21:14]

  Sentence: 1 + ~ 2 * 3

****** CFG1

  #+NAME CFG 1
  #+BEGIN_EXAMPLE
  E -> 1 | 2 | 3 | ~E | E+E | E*E | (E)
  #+END_EXAMPLE

  Parse Tree 1
  :           E
  :          /|\
  :         E + E
  :         |  /|\
  :         1 E * E
  :           |   |
  :          ~E   3
  :           |
  :           2

  Parse Tree 2
  :           E
  :          /|\
  :         E * E
  :        /|\  |
  :       E + E 3
  :       |   |
  :       1  ~E
  :           |
  :           2
****** CFG2
  #+NAME CFG 2
  #+BEGIN_EXAMPLE
  E -> E+T | T
  T -> T*F | F
  F -> 1 | 2 | 3 | ~F | (E)
  #+END_EXAMPLE

  :           E
  :          /|\
  :         / | \
  :        E  +  T
  :        |    /|\
  :        T   T * F
  :        |   |   |
  :        F   F   3
  :        |   |
  :        1  ~F
  :            |
  :            2
***** DONE 11.5.1.3
      CLOSED: [2019-02-20 Wed 21:24]
  I would argue that they denote the same context free language because they
  contain the same set of terminals and transitions. While the transition
  functions are not the same, (CFG1 is ambigious), they can produce language
  equivalent parse trees, meaning any sentance that can be turned into a parse
  tree with CFG1 can also be turned into a parse tree with CFG2 (and vice versa)

**** DONE 11.10.1 [100%]
     CLOSED: [2019-02-22 Fri 19:50]

***** DONE 11.10.1.5
      CLOSED: [2019-02-22 Fri 18:46]
****** Case 1 (OP is AND)
    L_{abcd} = {a^{i}b^{j}c^{k}d^{l} : i,j,k,l \ge 0 and ((i = j) AND (k = l))}

  #+BEGIN_EXAMPLE
    S => '' | AB
    A => '' | aAb
    B => '' | cBd
  #+END_EXAMPLE

****** Case 2 (OP is OR)

    L_{abcd} = {a^{i}b^{j}c^{k}d^{l} : i,j,k,l \ge 0 and ((i = j) OR (k = l))}

  #+BEGIN_EXAMPLE
    S => '' | XY | ABY | XCD
    X => '' | aXb
    Y => '' | cYd
    A => '' | aA
    B => '' | bB
    C => '' | cC
    D => '' | dD
  #+END_EXAMPLE

***** DONE 11.10.1.6
      CLOSED: [2019-02-22 Fri 19:50]

  L_acbd = {a^i c^k b^j d^l : i,j,k,l, \ge 0 and ((i = j) OP (k = l))

****** Case 1 OP=AND
  Assume L_acbd = {a^i c^k b^j d^l : i,j,k,l, \ge 0 and ((i = j) AND (k = l)) is context
  free.

  Pumping Lemma applies & garuntees an N > 0

  Pick N of the pumping lemma. Pick z = a^n c^n b^n d^n.
  Break z into uvwxy, with |vwx| \le n and vx \ne \epsilon.
  Then vwx contains one or two different symbols. In both cases, the string uwy
  connot be in L.

  Context Free Languages cannot match two substrings of arbitrary length over an
  alphabet of at least two symbols.

****** Case 2 OP=OR

  L_acbd = {a^i c^k b^j d^l : i,j,k,l, \ge 0 and ((i = j) OR (k = l))

  This isn't complete, but I feel like it is close
  #+BEGIN_EXAMPLE
    S => '' | AcBd | aCbD
    A => '' | aA
    B => '' | bB
    C => '' | cC
    D => '' | dD
  #+END_EXAMPLE



** Week 8 :noexport:

*** DONE Chapter 13 Exercises [100%]
    CLOSED: [2019-02-27 Wed 19:57]

**** DONE Exercise 13.8: DTM and NDTM Design [100%]
     CLOSED: [2019-02-27 Wed 19:57]
   
***** DONE 1
      CLOSED: [2019-02-27 Wed 19:57]
  #+name: tm1-end
  | Current | Symbol | Next  |  Symbol | Move      |
  | State   |   Read | State | Written | Direction |
  |---------+--------+-------+---------+-----------|
  | i0      |      . | fhalt |       0 | S         |
  | i0      |      0 | fhalt |       1 | S         |
  | i0      |      1 | q1    |       0 | R         |
  | q1      |      0 | fhalt |       1 | S         |
  | q1      |      1 | q1    |       0 | R         |
  | q1      |      . | fhalt |       1 | S         |

  #+name: tm1-desc
  #+BEGIN_SRC elisp :results output :var table=tm1-end
    (princ "TM\n")
    (loop for (cs sr ns sw md) in (cddr table)
          do (princ (format "%s : %s ; %s , %s -> %s\n" cs sr sw md ns)))
  #+END_SRC

  #+BEGIN_EXAMPLE
   TM
   i0 : . ; . , S -> fhalt
   i0 : 0 ; 1 , S -> fhalt
   i0 : 1 ; 0 , R -> q1
   q1 : 0 ; 1 , S -> fhalt
   q1 : 1 ; 0 , R -> q1
   q1 : . ; 1 , S -> fhalt
  #+END_EXAMPLE

***** DONE 2
      CLOSED: [2019-02-27 Wed 18:20]

  Assuming there is a '#' at the start of the string and a '$' at the end.
  If they do not exist, I would just add the states to add them before starting
  the "count".

  Basic idea, bounce back and forth "matching up" pairs of 1's and 0's until you
  run out. Depending on which number you've started on, you will need to accept or
  reject upon reaching a specific side of the tape. q2 handles switching between
  matching an initial 0 to a 1, or an initial 1 to a 0. Note, that a string such
  as 10011 would start with an initial 1, match it to the first zero, and then
  "restart" on the second zero. The q2 state handles that restart.

  I am making no claim that this is the "best" program for this particular
  problem, but it has worked on every string I've thrown at it.

  #+name: tm2-end
  | Current | Symbol | Symbol  | Move      | Next  |
  | State   | Read   | Written | Direction | State |
  |---------+--------+---------+-----------+-------|
  | i0      | #      | #       | R         | q2    |
  | q1      | *      | *       | R         | q1    |
  | q1      | 1      | 1       | S         | q2    |
  | q1      | $      | $       | S         | A     |
  | q1      | 0      | 0       | S         | q2    |
  | q2      | 1      | X       | R         | q3    |
  | q2      | 0      | Y       | R         | q5    |
  | q2      | *      | #       | R         | q2    |
  | q2      | #      | #       | S         | R     |
  | q3      | 0      | *       | L         | q4    |
  | q3      | 1      | 1       | R         | q3    |
  | q3      | *      | *       | R         | q3    |
  | q3      | $      | $       | S         | A     |
  | q4      | X      | #       | R         | q1    |
  | q4      | 1      | 1       | L         | q4    |
  | q4      | *      | *       | L         | q4    |
  | q5      | 0      | 0       | R         | q5    |
  | q5      | 1      | *       | L         | q6    |
  | q5      | #      | #       | S         | R     |
  | q5      | *      | *       | R         | q5    |
  | q5      | $      | $       | S         | R     |
  | q6      | 0      | 0       | L         | q6    |
  | q6      | 1      | 1       | L         | q6    |
  | q6      | Y      | #       | R         | q2    |
  | q6      | *      | *       | L         | q6   |


  #+name: tm2-desc
  #+BEGIN_SRC elisp :results output :var table=tm2-end
    (princ "TM\n")
    (loop for (cs sr sw md ns) in (cddr table)
          do (princ (format "%s : %s ; %s , %s -> %s\n" cs sr sw md ns)))
  #+END_SRC

  #+RESULTS: tm2-desc
  #+begin_example
  TM
  i0 : # ; # , R -> q2
  q1 : * ; * , R -> q1
  q1 : 1 ; 1 , S -> q2
  q1 : $ ; $ , S -> A
  q1 : 0 ; 0 , S -> q2
  q2 : 1 ; X , R -> q3
  q2 : 0 ; Y , R -> q5
  q2 : * ; # , R -> q2
  q2 : # ; # , S -> R
  q3 : 0 ; * , L -> q4
  q3 : 1 ; 1 , R -> q3
  q3 : * ; * , R -> q3
  q3 : $ ; $ , S -> A
  q4 : X ; # , R -> q1
  q4 : 1 ; 1 , L -> q4
  q4 : * ; * , L -> q4
  q5 : 0 ; 0 , R -> q5
  q5 : 1 ; * , L -> q6
  q5 : # ; # , S -> R
  q5 : * ; * , R -> q5
  q5 : $ ; $ , S -> R
  q6 : 0 ; 0 , L -> q6
  q6 : 1 ; 1 , L -> q6
  q6 : Y ; # , R -> q2
  q6 : * ; * , L -> q6
  #+end_example

  TM Graph
[[file:workbooks/graphs/tm2.png]]



** Week 9
*** Chapter 14 Exercises
**** 1 

  TM_INFINDFA = { \langle D \rangle : D is a DFA and L(D) is an infinite language }

  If L(D) is infinite, TM_INFINDFA accepts
  If L(D) is not intinite, TM_INFINDFA rejects

  Using the theorem B_D = { w \in \Sigma^* : w \in L(D) and p \le |w| \le 2p } where p is the
  number of states and \Sigma is the alphabet of DFA D, then L(D) is infinite if and
  only if B_D \ne \empty.

  Using this theorem, we can construct a TM that decides TM_INFINDFA. 

   * TM = On input \lang D \rang, where D is a DFA
   * Let /p/ be the number of states in DFA \lang D \rang.
   * Let \Sigma be the alphabet of DFA D.
   * For each string w \in \Sigma^* such that /p/ \le |/w/| \le 2p do:
      a. Run TM_DFA(\lang D, /w/\rang)
      b. If it accepts then accept
   * Otherwise Reject.
**** 2 
  Given LBA with tape of length S, alphabet A, and number of states Q, then the
  number of possible configurations of the LBA is QSA^S. If the machine does halt,
  it will halt within QSA^S iterations, otherwise the machine is stuck in a loop by
  virtue of the pigeonhole principle. 

  We can create a Turing Machine to run the LBA upto QSA^S steps and determine if
  it has halted within that many steps. If so, accept, otherwise reject. 
**** 3 
     CLOSED: [2019-03-06 Wed 12:37]
  Halt_TM = {\lang M, /w/ \rang: M is a TM and /w/ its input and M halts on /w/}

   * Keep listing pairs \lang M, /w/ \rang from \Sigma^* on an "internal tape"
   * Keep checking whether M is a Turing machine description. If so, M happens to be
     a Turing machine description.
   * Run Turing machine M on /w/, treating w as its input. Do not run to completion;
     instead engage in a dovetailed execution with all other TMs and inputs meanwhile
     being enumerated internally.
   * When the dovetailed simulation finds an \lang M, /w/ \rang pair such that M halts on /w/
     it lists the \lang M, /w/ \rang pair on the output tape.

  This listing will produce every \lang M, /w/ \rang such that M halts on w.
  The existence of this enumerator means that Halt_TM is RE. 
**** 4 
  Describe an enumerator for the language 'L_UnivCFG  

  'L_UnivCFG = {\lang G \rang : G is a CFG and L(G) \ne \Sigma^* }

   * Keep listing \lang G \rang from \Sigma^* on an "internal tape"
   * Keep checking whether G is a CFG. If so, G happens to be a CFG description
   * Begin running G on strings \lang /w/ \rang from \Sigma^*, treating /w/ as it's input. Do not
     run to completion, instead engage in a dovetailed execution with all other
     CFGs and inputs meanwhile being enumeratied internally. 
   * When the dovetailed simulation finds an \lang G, /w/ \rang pair such that /w/ \not \in
     L(G) it lists \lang G \rang on the output tape. 

**** 5 
  Semi-decider for whether or not a grammar G_1 has a language that is /not/
  contained in the language of another grammar G_2.
   * Keep enumerating strings from L(G_1)
   * Feed each enumerated string /w/ into G_2
   * If G_2 rejects /w/, return true (L(G_1) \nsub L(G_2))
 
  This is a semi decider, because both L(G_1) and L(G_2) could be infinite in size
  with L(G_1) \sube L(G_2) being true. If this is the case, the semi-decider will enter
  into an infinite loop and never return anything, without being able to return
  false, as it hasn't checked every string in L(G_1) against L(G_2). 
**** 6 
   * Suppose there is a decider SubCFG(G_1, G_2) that can determine whether grammar G_1
     generates a langage L(G_1) which is a subset of the langugage L(G_2) generated by
     grammar G_2. Suppose SubCFG(G_1, G_2) will halt and emit "yes" exactly when every
     string in L(G_1) has been found in L(G_2).

   * Ask the user for a grammar G_User

   * Create the Turing machine SubCFG(G_User, G_Univ) where G_Univ is a grammar for the
     universal language UnivCFG.

   * If SubCFG returns "yes", then G_Univ has a universal language - this is known
     to be impossible.

   * Therefore, SubCFG cannot exist.

  Decider for SubCFG 
  :  -----------------------------------
  :  | G_User          _______________  | Yes
  : -|--------------->>| Claimed     |--|>>
  :  |  ---------      | Decider for |  | No
  :  | | Grammar |--->>| L_SubCFG    |--|>>
  :  | |   for   |     |-------------|  |
  :  | |  G_Univ |                      |
  :  |  ---------                       |
  :  |___________________________________
**** 7 
   L_AmbCFG not RE 

   Recursively Enumerable languges are not closed under complementation. This means
   that the complement of a language L is only Recursively Enumerable if and only
   if L is also recursive. 

   If L and 'L are both Recurseively Enumerable languages, then L is decidable. 
   L is undecidable \rarr L is not R.E. || 'L is not R.E.


** Week 10
*** Monday March 11
**** Mapping Reducability
  f : \Sigma^* \rarr \Sigma^* is a computable function if 
  some Turing Machine M on every
  input w halts with just f(w) on its tape. 

**** Example Mapping Reduction
   1. Let A be a language known to be undecidable ("old" or "existing" language).
   2. Let B be the language that must be shown to be undecidable ("new" language).
   3. Find a mapping reduction /f/ from A to B.
   4. If B has a decider D_B then we can decide membership in A as follows

  Reduce Old to New 
  N<O? NO!

*** Friday March 15
**** Theorems 0-1
***** 0
      A language is decidable iff it is Turing-recognizable and co-Turing-recognizable
      RE = Turing recognizable
***** 1
      If A \le_m B and B is Turing-recognizable, then A is Turing-recognizable
      A is known language, B is unknown lanaguage
***** 2
      If L is a regular language, and A is mapping reducible to it, then A is decidable. 
*** Chapter 15 Exercises 
**** 15.2.3.1
***** Solution 1

Length is 75

PCP Solver Solution
#+BEGIN_EXAMPLE
  [1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 1, 1, 1, 3, 
   2, 1, 3, 3, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 1, 
   3, 3, 2, 1, 3, 2, 1, 1, 3, 3, 1, 1, 3, 2, 1, 
   3, 2, 2, 1, 1, 2, 2, 1, 3, 2, 2, 2, 2, 3, 3, 
   2, 2, 3, 3, 1, 2, 1, 1, 2, 3, 2, 2, 3, 2, 2]

  100 1   1   100 100 0   100 1   1   1   0   100 100 100 1   
  1   0   0   1   1   100 1   0   0   0   100 1   1   1   0   

  0   100 1   1   0   100 1   0   100 100 1   0   100 1   100 
  100 1   0   0   100 1   0   100 1   1   0   100 1   0   1   

  1   1   0   100 1   0   100 100 1   1   100 100 1   0   100 
  0   0   100 1   0   100 1   1   0   0   1   1   0   100 1   

  1   0   0   100 100 0   0   100 1   0   0   0   0   1   1   
  0   100 100 1   1   100 100 1   0   100 100 100 100 0   0   

  0   0   1   1   100 0   100 100 0   1   0   0   1   0   0   
  100 100 0   0   1   100 1   1   100 0   100 100 0   100 100 
#+END_EXAMPLE
***** Solution 2

Length is 75

PCP Solver Solution
#+BEGIN_EXAMPLE
  [1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 2, 1, 1, 1, 3, 
   1, 3, 3, 2, 2, 1, 2, 1, 2, 2, 3, 1, 3, 3, 3, 
   3, 1, 2, 1, 1, 1, 1, 2, 3, 2, 1, 3, 3, 2, 2, 
   3, 1, 3, 2, 1, 2, 1, 1, 3, 3, 1, 3, 2, 3, 2,
   2, 1, 1, 2, 1, 3, 2, 2, 2, 3, 2, 2, 3, 2, 2]
  100 1   1   100 100 0   100 1   1   1   0   100 100 100 1   
  1   0   0   1   1   100 1   0   0   0   100 1   1   1   0   

  100 1   1   0   0   100 0   100 0   0   1   100 1   1   1   
  1   0   0   100 100 1   100 1   100 100 0   1   0   0   0   

  1   100 0   100 100 100 100 0   1   0   100 1   1   0   0   
  0   1   100 1   1   1   1   100 0   100 1   0   0   100 100 

  1   100 1   0   100 0   100 100 1   1   100 1   0   1   0   
  0   1   0   100 1   100 1   1   0   0   1   0   100 0   100 

  0   100 100 0   100 1   0   0   0   1   0   0   1   0   0   
  100 1   1   100 1   0   100 100 100 0   100 100 0   100 100 

#+END_EXAMPLE
**** 15.2.3.4 

    a. Done in Jove


    b. 

      i.

      Given this scenario (len(T_i[0] < len(T_i1) or T_i[0] > len(T_i[1]) for all T_i),
      then there will never be a solution due to the fact that with this
      constraint one side of the string will never be able to catch up to the
      other. 
     
      ii. 
     This condition indicates that for at least two of the tiles, 
     have a top where |T_j[0]| < |T_j[1]| and |T_k[0]| > T_k[1]|

     Given the properties of the GCD and LCM, we can prove that there is an
     infinite number of solutions to a diophantine with the following constraints: 
     Mx + Py = Nx + Ry and M > N and P < R

     Therefore, we can create a decider for a unary PCP that behaves like the
     following: 
   
        Given a set of tiles, T:
           if \exist t \in T : |t[0]| == |t[1]| -> accept (we have found a trivial solution)
         
           if \forall q,r \in T : (|q[0]| < |r[1]|) \lor (|q[0]| > |r[1]|) -> reject (one side
           will never catch up to the other)

           if \exist q,r \in T : (|q[0]| < |r[1]|) \land (q[0]| > |r[1]|) -> accept (some
           combination of tiles will result in a match)

**** 15.5.1.3

  Mapping reduction from Halt_TM to A_TM

   * Let HALT_TM = { \lang M, /w/ \rang : M halts on input /w/}

   * Assume HALT_TM is decidable.

   * Assume there is a decider for A_TM called D_ATM(M', /w/) where
#+BEGIN_EXAMPLE
      D_ATM(M', /w/):
        accepts => M' accepts /w/ => M accepts /w/
      
        rejects => M' rejects /w/ => M rejects /w/ or loops
#+END_EXAMPLE
   * Now construct a decider for HALT_TM D_HALTTM(M', /w/) where
   
#+BEGIN_EXAMPLE
     D_HALTTM(M', /w/):
        accepts => M' accepts /w/ => M accepts or rejects /w/

        rejects => M' rejects /w/ => M loops
#+END_EXAMPLE
   *  We can now redefine an algorithm for D_ATM:

#+BEGIN_EXAMPLE
    Run D_HALTTM on \lang M, /w/ \rang:
      If D_HALTTM rejects => reject
      If D_HALTTM accepts => continue
    Run M on /w/:
      If M accepts => accept
      If M rejects => reject
#+END_EXAMPLE
  * This has created a contradiction. If a decider for the Halt_TM could be
    created, then we could create a decider for A_TM. We know A_TM is undecidable,
    therefore a decider for Halt_TM cannot exist.

**** 15.5.1.5

#+BEGIN_EXAMPLE
   CFL_TM = { \lang M \rang : M is a TM whose language is context-free. }

   A_TM to CFL_TM

   A \le_m CFL_TM

  Decider_CFLTM (M')

     M'(x) (where x is form \lang M, /w/ \rang{
        if x is of the form a^{n}b^{n}c^{n} accept
        Run M on /w/
           If M accepts /w/ => accept
           If M rejects /w/ => reject
     }
#+END_EXAMPLE
 

** Week 11
*** Chapter 16.7.2 Exercises

**** Exercise 4
  #+BEGIN_SRC elisp :results  raw
  (setq formula2 '(((a) b) ((b) c) ((c) d) ((d) a)))
  (to-dimacs formula2)
  #+END_SRC

  #+RESULTS:
  p cnf 4 4
  -4 1 0
  -1 2 0
  -2 3 0
  -3 4 0 

  This is satisfiable via CryptoMiniSat.

**** Exercise 6 
  #+BEGIN_SRC elisp :results raw 
  (setq formula3 '(((a) b) ((b) c) ((c) d) ((d) (a)) (a a)))
  (to-dimacs formula3)
  #+END_SRC

  #+RESULTS:
  p cnf 4 5
  -4 1 0
  -1 2 0
  -2 3 0
  -3 -4 0
  4 4 0 

  This was not satisfiable via CryptoMiniSat.

**** Exercise 8
  A clique has k(k-1)/2 edges. So k=5 has 10 edges. 

  There are (k-1)!/2 distinct Hamiltonian cycles in a complete graph. A clique is
  a complete subgraph g of graph G, so therefore a clique with size k=5 will have:

:     (5-1)!/2 = 4!/2 = 4*3*2*1/2 = 24/2 = 12

  There will be (n-1)!/2 Hamiltonian cycles in a clique of size k=n

** Week 12 
*** Chapter 17 Exercises
**** 1
***** 4 input NOR function

#+NAME: fig:4 Input NOR Function
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 5.0in
  [[file:./workbooks/graphs/4nor.png]]


#+Begin_Latex
\pagebreak
#+End_Latex
***** 4 input AND function

#+NAME: fig:4 Input AND Function
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 5.0in
  [[file:./workbooks/graphs/4And.png]]

***** Comparison
      The have the same tree structure, but the edge labels are switched. Every
      edge labeled with a /1/ in the 4 input NOR function is labeled with a /0/ on
      the 4 input AND function and vice versa. Every edge labeled /0/ in the 4 input NOR
      function is labeled with a /1/ on the 4 input AND function.

#+Begin_Latex
\pagebreak
#+End_Latex
**** 2
***** 5 XNOR

#+NAME: fig:5 Input XNOR Function
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 4.0in
      [[file:./workbooks/graphs/5XNOR.png]]

***** Comparison
  The only change is on the edges from e to the accept/reject states. The XNOR
  function swaps the 1 and 0 on each /e/ node to the accept/reject state.
  This negates the output, which is the definition of the XNOR function.
**** 3

  :  x1
  :  | \  0
  :  |  \
  :  |   x2
  :  |   | \  0
  :  |   |  \
  :  |   |   x3
  : 1|   |   | \  0
  :  |   |   |  \
  :  |  1|   |   x4
  :  |   |  1|   | \ 
  :  |   |   |  1|  \  0
  :  \   |   |   /   \
  :   \  |   |  /     \
  :   ----------    -----------
  :  |    1    |   |    0      |
  :  |_________|   |___________|

  Yes, this is a linearly sized BDD. 
  It is the same as the PBDD output
**** 4
***** a)
  No, it is incorrect. The BDD allows several invalid acceptance states such as
  the following where A \gt B:
  #+BEGIN_EXAMPLE
  A: '010', B: '001'
  A: '100', B: '001'
  A: '101', B: '011'
  A: '110', B: '011'
  A: '110', B: '101'
  A: '100', B: '011'
  A: '101', B: '010'
  A: '110', B: '001'
  A: '100', B: '010'
  #+END_EXAMPLE

#+NAME: fig:Incorrect less-than BDD
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 4.0in
  [[file:./workbooks/graphs/incorrectLT.png]]

***** b)
  Old
  #+BEGIN_EXAMPLE
  Var_Order : a2, b2, a1, b1, a0, b0
  Main_Exp : ~a2 & b2 | ~a1 & b1 | ~a0 & b0
  #+END_EXAMPLE

  Modified
  #+BEGIN_EXAMPLE
  Var_Order : x2 y2 x1 y1 x0 y0
  Main_Exp :   (~x2 & y2) | 
               (~(x2 XOR y2) & (~x1 & y1)) | 
               ((~(x2 XOR y2) & ~(x1 XOR y1)) & (~x0 & y0))
  #+END_EXAMPLE

#+NAME: fig:Corrected less-than BDD
#+ATTR_ORG: :width 200/250/300/400/500/600
#+ATTR_LATEX: :width 4.0in
  [[file:./workbooks/graphs/altb.png]]

** Week 13
*** Lambdafication
  #+BEGIN_SRC elisp :results silent :lexical t
      (fset 'I (set 'I (lambda (x) x)))

      (fset 'Z (set 'Z (lambda (x) (lambda (y) y))))

      (fset 'S
            (set 'S
                 (lambda (a)
                   (lambda (b)
                     (lambda (c)
                       (funcall b
                                (funcall
                                   (funcall a b) c)))))))

    (fset 'ADD
          (set 'ADD
               (lambda (a)
                 (lambda (b) (funcall (funcall a S) b)))))

    (fset 'MUL
          (set 'MUL
               (lambda (a)
                 (lambda (b)
                   (lambda (c)
                      (funcall a (funcall b c)))))))

    (fset 'TRUE
          (set 'TRUE
               (lambda (a)
                 (lambda (b)
                         a))))

    (fset 'FALSE
          (set 'FALSE
               (lambda (a)
                 (lambda (b)
                   b))))

    (fset 'NOT
          (set 'NOT
               (lambda (a)
                 (funcall (funcall a FALSE) TRUE))))

    (fset 'AND
          (set 'AND
               (lambda (a)
                  (lambda (b)
                     (funcall (funcall a b) a)))))


    (fset 'OR
          (set 'OR
               (lambda (a)
                 (lambda (b) 
                   (funcall (funcall a a) b)))))

    (fset 'ZP
          (set 'ZP
              (lambda (a)
                      (funcall (funcall (funcall a FALSE) NOT) FALSE))))

    (fset 'PAIR 
         (set 'PAIR
              (lambda (x)
                  (lambda (y)
                      (lambda (f)
                         (funcall (funcall f x) y))))))

    (fset 'FIRST
         (set 'FIRST
              (lambda (p) (funcall p TRUE))))

    (fset 'SECOND
         (set 'SECOND
              (lambda (p) (funcall p FALSE))))

    (fset 'Y
         (set 'Y
            (lambda (f) 
               ((lambda (x) (funcall x x)
                (lambda (x) (funcall f (lambda (&rest v)
                                       (apply (funcall x x) v)))))))))

  #+END_SRC
  #+BEGIN_SRC elisp :results silent 

    (defun lambda-to-bool (b)
       (funcall (funcall b t) nil))

  
    (defun bool-to-lambda (b)
       (if b
           TRUE
         FALSE))


    (defun church-to-nat (c)
    (funcall (funcall c '1+) 0))

    (defun nat-to-church (n)
       (if (zerop n)
          Z
          (funcall S (nat-to-church (1- n)))))

    (defun lambda-s (x)
       (1+ x))

    (defun lambda-add (x y)
       (if (zerop y)
          x
       (lambda-s (lambda-add x (1- y)))))

    (defun lambda-mul (x y)
       (if (zerop y)
           0
         (if (= 1 y)
            x
           (lambda-add x (lambda-mul x (1- y))))))

    (defun lambda-ex (x y)
       (if (zerop y)
          1
        (if (= 1 y)
            x
          (lambda-mul x (lambda-ex x (1- y)))))) 
  #+END_SRC

  #+BEGIN_SRC elisp :results raw
  (lambda-to-bool (funcall (funcall AND TRUE) FALSE))
  (bool-to-lambda nil)
  #+END_SRC


*** Chapter 18 Exercises
**** Exercise 18.4.1
     ADD applies the successor function repeatedly until the numbers have been added.
     MUL does the same, although instead of repeating the successor function, it
     repeats the addition function.
**** Exercise 18.4.2
  #+BEGIN_SRC elisp
  (church-to-nat (funcall (funcall MUL (nat-to-church 4)) (nat-to-church 8)))
  #+END_SRC

  #+RESULTS:
  : 32

**** Exercise 18.5.1
  #+BEGIN_SRC elisp :results raw
  (lambda-to-bool (funcall (funcall (funcall PAIR TRUE) FALSE) AND))
  #+END_SRC

  #+RESULTS:
  t

**** Exercise 18.5.2

  #+BEGIN_SRC elisp :results raw
  (lambda-to-bool (funcall (funcall (funcall PAIR TRUE) FALSE) OR))
  #+END_SRC

  #+RESULTS:
  t

**** Exercise 18.8.1 

  A fixpoint combinator is a combinator /E/ such that for any lambda expression
  /G/, the identity (/EG/) = /G/(/EG/) holds. There are an infinite number of
  fixpoint combinators. 


  \textit{Y} = (\lambda f.(\lambda x. f(x x))(\lambda x. f(x x)))

  \textit{Y_e} = (\lambda f.(\lambda x.(x x))(\lambda y.f(\lambda v. ((y y) v))))

  EG = (\lambda f.(\lambda x. (x x))(\lambda y.f(\lambda v. ((y y) v))))G

     = (\lambda f.(\lambda x.x x) (\lambda y.f (\lambda v. y y v)))G
 
     = (\lambda f.(\lambda y.f (\lambda v.y y v))(\lambda y.f (\lambda v. y y v)))G

     = (\lambda y.G(\lambda v. y y v))(\lambda y.G(\lambda v. y y v ))

     = G(\lambda v. (\lambda y.G(\lambda v. y y v ))(\lambda y.G(\lambda v. y y v )) v)
 
     = G (\lambda y.G(\lambda v. y y v))(\lambda y.G(\lambda v. y y v))

     thus EG = G(EG) and Y_e is a fixpoint combinator

**** Exercise 18.8.2

  #+BEGIN_SRC python :results output
    # Below, for clarity, we use don't use Church numerals..
    # The Ye -- eager Y combinator

    Ye = lambda f: (lambda x: x(x))(lambda y: f(lambda v: y(y)(v)))
    # Pre-Factorial: performs the product of 
    # a natural number and all natural number less than it
    # We call it pre-factorial because we need to apply
    # Y to it to obtain the real factorial

    prefact = lambda fact: lambda n: (1 if n==0 else n*fact(n-1))

    # Pre-sum: sums all the natural numbers less than the given number

    presum = lambda f: lambda n: (0 if n==0 else n+f(n-1))

    # Pre-Fib: returns the nth number of the series defined by 
    # the following definitions
    #  the first two numbers are 1 and 1
    #  the next number is defined as the sum of the prior two numbers

    prefib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))

    fact = lambda n: Ye(prefact)(n)
    sum = lambda n: Ye(presum)(n)

    print("fact examples")
    print(fact(3))
    print(fact(5))
    print(fact(8))
    print("Sum examples")
    print(sum(3))
    print(sum(5))
    print(sum(8))
  #+END_SRC

  #+RESULTS:
  : fact examples
  : 6
  : 120
  : 40320
  : Sum examples
  : 6
  : 15
  : 36

**** Exercise 18.8.3


  Y_e is a fixed-point function due to Tennent's correspondence principle. 
  Breaking down Y_e, we see that it is very similar to Y. The difference being that
  instead of evaluating the second \lambda x. f(x x) immedeiatly, we defer it into
  another wrapped lambda. This is essentially a no-op, as all it does it place the
  order of the inner function further back in queue for evalutation. This is why
  the applicative (eager) Y combinator works with eager languages. Instead of
  returning a "value" it returns another layered function. This means that eager
  languages will stop evaluation there, preventing an infinite loop of self
  evalutation. 


 
