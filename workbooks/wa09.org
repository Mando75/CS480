#+TITLE: Week 09 Workbook
#+AUTHOR: Bryan Muller
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t ':t
#+OPTIONS: html-postamble:nil
#+STARTUP: showeverything entitiespretty inlineimages


* DONE Monday
  CLOSED: [2019-03-06 Wed 12:52]
#+BEGIN_SRC elisp 
(read "(print (list \"hello world!\" (+ 5 2)))")
#+END_SRC

#+RESULTS:

Marvin Minsky 

* DONE Wednesday
  CLOSED: [2019-03-06 Wed 20:53]
** Ackermann's Function

- A(0, y) = 1 for y \ge 0
- A(1, 0) = 2
- A(x, 0) = x + 2 for x \ge 2
- A(x, y) = A(A(x - 1, y), y - 1) for x, y > 1

* DONE Chapter 14 Exercises: 14.4.1 [100%]
  CLOSED: [2019-03-06 Wed 20:53]
** DONE 1 
   CLOSED: [2019-03-05 Tue 18:29]

TM_INFINDFA = { \langle D \rangle : D is a DFA and L(D) is an infinite language }

If L(D) is infinite, TM_INFINDFA accepts
If L(D) is not intinite, TM_INFINDFA rejects

Using the theorem B_D = { w \in \Sigma^* : w \in L(D) and p \le |w| \le 2p } where p is the
number of states and \Sigma is the alphabet of DFA D, then L(D) is infinite if and
only if B_D \ne \empty.

Using this theorem, we can construct a TM that decides TM_INFINDFA. 

 * TM = On input \lang D \rang, where D is a DFA
 * Let /p/ be the number of states in DFA \lang D \rang.
 * Let \Sigma be the alphabet of DFA D.
 * For each string w \in \Sigma^* such that /p/ \le |/w/| \le 2p do:
    a. Run TM_DFA(\lang D, /w/\rang)
    b. If it accepts then accept
 * Otherwise Reject.
 * 
** DONE 2 
   CLOSED: [2019-03-05 Tue 20:08]
Given LBA with tape of length S, alphabet A, and number of states Q, then the
number of possible configurations of the LBA is QSA^S. If the machine does halt,
it will halt within QSA^S iterations, otherwise the machine is stuck in a loop by
virtue of the pigeonhole principle. 

We can create a Turing Machine to run the LBA upto QSA^S steps and determine if
it has halted within that many steps. If so, accept, otherwise reject. 
** DONE 3 
   CLOSED: [2019-03-06 Wed 12:37]
Halt_TM = {\lang M, /w/ \rang: M is a TM and /w/ its input and M halts on /w/}

 * Keep listing pairs \lang M, /w/ \rang from \Sigma^* on an "internal tape"
 * Keep checking whether M is a Turing machine description. If so, M happens to be
   a Turing machine description.
 * Run Turing machine M on /w/, treating w as its input. Do not run to completion;
   instead engage in a dovetailed execution with all other TMs and inputs meanwhile
   being enumerated internally.
 * When the dovetailed simulation finds an \lang M, /w/ \rang pair such that M halts on /w/
   it lists the \lang M, /w/ \rang pair on the output tape.

This listing will produce every \lang M, /w/ \rang such that M halts on w.
The existence of this enumerator means that Halt_TM is RE. 
** DONE 4 
   CLOSED: [2019-03-06 Wed 19:02]
Describe an enumerator for the language 'L_UnivCFG  

'L_UnivCFG = {\lang G \rang : G is a CFG and L(G) \ne \Sigma^* }

 * Keep listing \lang G \rang from \Sigma^* on an "internal tape"
 * Keep checking whether G is a CFG. If so, G happens to be a CFG description
 * Begin running G on strings \lang /w/ \rang from \Sigma^*, treating /w/ as it's input. Do not
   run to completion, instead engage in a dovetailed execution with all other
   CFGs and inputs meanwhile being enumeratied internally. 
 * When the dovetailed simulation finds an \lang G, /w/ \rang pair such that /w/ \not \in
   L(G) it lists \lang G \rang on the output tape. 

** DONE 5 
   CLOSED: [2019-03-06 Wed 20:23]
Semi-decider for whether or not a grammar G_1 has a language that is /not/
contained in the language of another grammar G_2.
 * Keep enumerating strings from L(G_1)
 * Feed each enumerated string /w/ into G_2
 * If G_2 rejects /w/, return true (L(G_1) \nsub L(G_2))
 
This is a semi decider, because both L(G_1) and L(G_2) could be infinite in size
with L(G_1) \sube L(G_2) being true. If this is the case, the semi-decider will enter
into an infinite loop and never return anything, without being able to return
false, as it hasn't checked every string in L(G_1) against L(G_2). 
** DONE 6 
   CLOSED: [2019-03-06 Wed 20:47]
 * Suppose there is a decider SubCFG(G_1, G_2) that can determine whether grammar G_1
   generates a langage L(G_1) which is a subset of the langugage L(G_2) generated by
   grammar G_2. Suppose SubCFG(G_1, G_2) will halt and emit "yes" exactly when every
   string in L(G_1) has been found in L(G_2).

 * Ask the user for a grammar G_User

 * Create the Turing machine SubCFG(G_User, G_Univ) where G_Univ is a grammar for the
   universal language UnivCFG.

 * If SubCFG returns "yes", then G_Univ has a universal language - this is known
   to be impossible.

 * Therefore, SubCFG cannot exist.

Decider for SubCFG 
:  -----------------------------------
:  | G_User          _______________  | Yes
: -|--------------->>| Claimed     |--|>>
:  |  ---------      | Decider for |  | No
:  | | Grammar |--->>| L_SubCFG    |--|>>
:  | |   for   |     |-------------|  |
:  | |  G_Univ |                      |
:  |  ---------                       |
:  |___________________________________
** DONE 7 
   CLOSED: [2019-03-06 Wed 20:53]
'L_AmbCFG not RE

Recursively Enumerable languges are not closed under complementation. This means
that the complement of a language L is only Recursively Enumerable if and only
if L is also recursive. 

